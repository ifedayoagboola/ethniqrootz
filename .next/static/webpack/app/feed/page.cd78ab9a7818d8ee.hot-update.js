"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/feed/page",{

/***/ "(app-pages-browser)/./src/hooks/useSaves.ts":
/*!*******************************!*\
  !*** ./src/hooks/useSaves.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSaves: () => (/* binding */ useSaves)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _stores_saveStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/stores/saveStore */ \"(app-pages-browser)/./src/stores/saveStore.ts\");\n/* harmony import */ var _stores_loadingStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/stores/loadingStore */ \"(app-pages-browser)/./src/stores/loadingStore.ts\");\n/* harmony import */ var _lib_saves__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/saves */ \"(app-pages-browser)/./src/lib/saves.ts\");\n\n\n\n\nfunction useSaves() {\n    const { savedProducts, saveCounts, error, setSavedProducts, addSavedProduct, removeSavedProduct, setSaveCount, setError, isProductSaved: isProductSavedInStore, getSaveCount: getSaveCountFromStore, clearError, batchUpdateSaveData } = (0,_stores_saveStore__WEBPACK_IMPORTED_MODULE_1__.useSaveStore)();\n    const { setLoading } = (0,_stores_loadingStore__WEBPACK_IMPORTED_MODULE_2__.useLoadingStore)();\n    // Load user's saved products on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSaves.useEffect\": ()=>{\n            loadUserSavedProducts();\n        }\n    }[\"useSaves.useEffect\"], []);\n    const loadUserSavedProducts = async ()=>{\n        setError(null);\n        try {\n            const result = await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.getUserSavedProducts)();\n            if (result.success && result.productIds) {\n                setSavedProducts(result.productIds);\n            } else if (result.error) {\n                setError(result.error);\n            }\n        } catch (error) {\n            setError('Failed to load saved products');\n        }\n    };\n    // Batch load save data for multiple products\n    const loadProductsSaveData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSaves.useCallback[loadProductsSaveData]\": async (productIds)=>{\n            try {\n                const result = await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.batchGetProductsSaveData)(productIds);\n                if (result.success && result.data) {\n                    batchUpdateSaveData(result.data);\n                } else if (result.error) {\n                    console.error('Error loading products save data:', result.error);\n                }\n            } catch (error) {\n                console.error('Error loading products save data:', error);\n            }\n        }\n    }[\"useSaves.useCallback[loadProductsSaveData]\"], [\n        batchUpdateSaveData\n    ]);\n    const loadProductSaveCount = async (productId)=>{\n        try {\n            const result = await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.getProductSaveCount)(productId);\n            if (result.success && result.count !== undefined) {\n                setSaveCount(productId, result.count);\n            } else if (result.error) {\n                console.error('Error loading save count:', result.error);\n            }\n        } catch (error) {\n            console.error('Error loading save count:', error);\n        }\n    };\n    const toggleSave = async (productId)=>{\n        setLoading(true, 'Saving...');\n        setError(null);\n        try {\n            const isCurrentlySaved = isProductSavedInStore(productId);\n            const result = isCurrentlySaved ? await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.unsaveProduct)(productId) : await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.saveProduct)(productId);\n            if (result.success) {\n                if (isCurrentlySaved) {\n                    removeSavedProduct(productId);\n                } else {\n                    addSavedProduct(productId);\n                }\n                if (result.saveCount !== undefined) {\n                    setSaveCount(productId, result.saveCount);\n                }\n                return {\n                    success: true\n                };\n            } else {\n                setError(result.error || 'Failed to save product');\n                return {\n                    success: false,\n                    error: result.error\n                };\n            }\n        } catch (error) {\n            const errorMessage = 'Failed to save product';\n            setError(errorMessage);\n            return {\n                success: false,\n                error: errorMessage\n            };\n        } finally{\n            setLoading(false);\n        }\n    };\n    // Batch toggle multiple saves\n    const batchToggleSavesAction = async (productIds, action)=>{\n        setLoading(true, \"\".concat(action === 'save' ? 'Saving' : 'Removing', \" products...\"));\n        setError(null);\n        try {\n            const result = await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.batchToggleSaves)(productIds, action);\n            if (result.success && result.results) {\n                // Update store with batch results\n                result.results.forEach((param)=>{\n                    let { productId, isSaved, saveCount } = param;\n                    if (isSaved) {\n                        addSavedProduct(productId);\n                    } else {\n                        removeSavedProduct(productId);\n                    }\n                    setSaveCount(productId, saveCount);\n                });\n                return {\n                    success: true,\n                    results: result.results\n                };\n            } else {\n                setError(result.error || 'Failed to batch toggle saves');\n                return {\n                    success: false,\n                    error: result.error\n                };\n            }\n        } catch (error) {\n            const errorMessage = 'Failed to batch toggle saves';\n            setError(errorMessage);\n            return {\n                success: false,\n                error: errorMessage\n            };\n        } finally{\n            setLoading(false);\n        }\n    };\n    const checkProductSaveStatus = async (productId)=>{\n        try {\n            const result = await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.isProductSaved)(productId);\n            if (result.success && result.isSaved !== undefined) {\n                if (result.isSaved) {\n                    addSavedProduct(productId);\n                } else {\n                    removeSavedProduct(productId);\n                }\n            } else if (result.error) {\n                console.error('Error checking save status:', result.error);\n            }\n        } catch (error) {\n            console.error('Error checking save status:', error);\n        }\n    };\n    return {\n        // State\n        savedProducts: Array.from(savedProducts),\n        saveCounts,\n        error,\n        // Actions\n        toggleSave,\n        batchToggleSaves: batchToggleSavesAction,\n        loadProductSaveCount,\n        loadProductsSaveData,\n        checkProductSaveStatus,\n        loadUserSavedProducts,\n        clearError,\n        // Helpers\n        isProductSaved: isProductSavedInStore,\n        getSaveCount: getSaveCountFromStore\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VTYXZlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0M7QUFDRztBQUNNO0FBU25DO0FBRWQsU0FBU1c7SUFDWixNQUFNLEVBQ0ZDLGFBQWEsRUFDYkMsVUFBVSxFQUNWQyxLQUFLLEVBQ0xDLGdCQUFnQixFQUNoQkMsZUFBZSxFQUNmQyxrQkFBa0IsRUFDbEJDLFlBQVksRUFDWkMsUUFBUSxFQUNSWCxnQkFBZ0JZLHFCQUFxQixFQUNyQ0MsY0FBY0MscUJBQXFCLEVBQ25DQyxVQUFVLEVBQ1ZDLG1CQUFtQixFQUN0QixHQUFHdEIsK0RBQVlBO0lBRWhCLE1BQU0sRUFBRXVCLFVBQVUsRUFBRSxHQUFHdEIscUVBQWVBO0lBRXRDLHNDQUFzQztJQUN0Q0gsZ0RBQVNBOzhCQUFDO1lBQ04wQjtRQUNKOzZCQUFHLEVBQUU7SUFFTCxNQUFNQSx3QkFBd0I7UUFDMUJQLFNBQVM7UUFFVCxJQUFJO1lBQ0EsTUFBTVEsU0FBUyxNQUFNckIsZ0VBQW9CQTtZQUN6QyxJQUFJcUIsT0FBT0MsT0FBTyxJQUFJRCxPQUFPRSxVQUFVLEVBQUU7Z0JBQ3JDZCxpQkFBaUJZLE9BQU9FLFVBQVU7WUFDdEMsT0FBTyxJQUFJRixPQUFPYixLQUFLLEVBQUU7Z0JBQ3JCSyxTQUFTUSxPQUFPYixLQUFLO1lBQ3pCO1FBQ0osRUFBRSxPQUFPQSxPQUFPO1lBQ1pLLFNBQVM7UUFDYjtJQUNKO0lBRUEsNkNBQTZDO0lBQzdDLE1BQU1XLHVCQUF1QjdCLGtEQUFXQTtzREFBQyxPQUFPNEI7WUFDNUMsSUFBSTtnQkFDQSxNQUFNRixTQUFTLE1BQU1sQixvRUFBd0JBLENBQUNvQjtnQkFDOUMsSUFBSUYsT0FBT0MsT0FBTyxJQUFJRCxPQUFPSSxJQUFJLEVBQUU7b0JBQy9CUCxvQkFBb0JHLE9BQU9JLElBQUk7Z0JBQ25DLE9BQU8sSUFBSUosT0FBT2IsS0FBSyxFQUFFO29CQUNyQmtCLFFBQVFsQixLQUFLLENBQUMscUNBQXFD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TyxLQUFLVCxXQUFXO2dCQUNoRCxJQUFJVCxPQUFPa0IsT0FBTyxFQUFFO29CQUNoQjdCLGdCQUFnQmtCO2dCQUNwQixPQUFPO29CQUNIakIsbUJBQW1CaUI7Z0JBQ3ZCO1lBQ0osT0FBTyxJQUFJUCxPQUFPYixLQUFLLEVBQUU7Z0JBQ3JCa0IsUUFBUWxCLEtBQUssQ0FBQywrQkFBK0JhLE9BQU9iLEtBQUs7WUFDN0Q7UUFDSixFQUFFLE9BQU9BLE9BQU87WUFDWmtCLFFBQVFsQixLQUFLLENBQUMsK0JBQStCQTtRQUNqRDtJQUNKO0lBRUEsT0FBTztRQUNILFFBQVE7UUFDUkYsZUFBZW1DLE1BQU1DLElBQUksQ0FBQ3BDO1FBQzFCQztRQUNBQztRQUVBLFVBQVU7UUFDVnVCO1FBQ0EzQixrQkFBa0IrQjtRQUNsQlI7UUFDQUg7UUFDQWdCO1FBQ0FwQjtRQUNBSDtRQUVBLFVBQVU7UUFDVmYsZ0JBQWdCWTtRQUNoQkMsY0FBY0M7SUFDbEI7QUFDSiIsInNvdXJjZXMiOlsiL1VzZXJzL2lmZWRheW9hZ2Jvb2xhL0Rlc2t0b3AvbXlQcm9qZWN0cy9ldGhuaXFyb290ei1uZXh0anMvc3JjL2hvb2tzL3VzZVNhdmVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VTYXZlU3RvcmUgfSBmcm9tICdAL3N0b3Jlcy9zYXZlU3RvcmUnO1xuaW1wb3J0IHsgdXNlTG9hZGluZ1N0b3JlIH0gZnJvbSAnQC9zdG9yZXMvbG9hZGluZ1N0b3JlJztcbmltcG9ydCB7XG4gICAgc2F2ZVByb2R1Y3QsXG4gICAgdW5zYXZlUHJvZHVjdCxcbiAgICBnZXRVc2VyU2F2ZWRQcm9kdWN0cyxcbiAgICBnZXRQcm9kdWN0U2F2ZUNvdW50LFxuICAgIGlzUHJvZHVjdFNhdmVkLFxuICAgIGJhdGNoR2V0UHJvZHVjdHNTYXZlRGF0YSxcbiAgICBiYXRjaFRvZ2dsZVNhdmVzXG59IGZyb20gJ0AvbGliL3NhdmVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNhdmVzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgICAgc2F2ZWRQcm9kdWN0cyxcbiAgICAgICAgc2F2ZUNvdW50cyxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHNldFNhdmVkUHJvZHVjdHMsXG4gICAgICAgIGFkZFNhdmVkUHJvZHVjdCxcbiAgICAgICAgcmVtb3ZlU2F2ZWRQcm9kdWN0LFxuICAgICAgICBzZXRTYXZlQ291bnQsXG4gICAgICAgIHNldEVycm9yLFxuICAgICAgICBpc1Byb2R1Y3RTYXZlZDogaXNQcm9kdWN0U2F2ZWRJblN0b3JlLFxuICAgICAgICBnZXRTYXZlQ291bnQ6IGdldFNhdmVDb3VudEZyb21TdG9yZSxcbiAgICAgICAgY2xlYXJFcnJvcixcbiAgICAgICAgYmF0Y2hVcGRhdGVTYXZlRGF0YSxcbiAgICB9ID0gdXNlU2F2ZVN0b3JlKCk7XG5cbiAgICBjb25zdCB7IHNldExvYWRpbmcgfSA9IHVzZUxvYWRpbmdTdG9yZSgpO1xuXG4gICAgLy8gTG9hZCB1c2VyJ3Mgc2F2ZWQgcHJvZHVjdHMgb24gbW91bnRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsb2FkVXNlclNhdmVkUHJvZHVjdHMoKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBsb2FkVXNlclNhdmVkUHJvZHVjdHMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRVc2VyU2F2ZWRQcm9kdWN0cygpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5wcm9kdWN0SWRzKSB7XG4gICAgICAgICAgICAgICAgc2V0U2F2ZWRQcm9kdWN0cyhyZXN1bHQucHJvZHVjdElkcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKHJlc3VsdC5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBzZXRFcnJvcignRmFpbGVkIHRvIGxvYWQgc2F2ZWQgcHJvZHVjdHMnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBCYXRjaCBsb2FkIHNhdmUgZGF0YSBmb3IgbXVsdGlwbGUgcHJvZHVjdHNcbiAgICBjb25zdCBsb2FkUHJvZHVjdHNTYXZlRGF0YSA9IHVzZUNhbGxiYWNrKGFzeW5jIChwcm9kdWN0SWRzOiBzdHJpbmdbXSkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYmF0Y2hHZXRQcm9kdWN0c1NhdmVEYXRhKHByb2R1Y3RJZHMpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hVcGRhdGVTYXZlRGF0YShyZXN1bHQuZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgcHJvZHVjdHMgc2F2ZSBkYXRhOicsIHJlc3VsdC5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHByb2R1Y3RzIHNhdmUgZGF0YTonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9LCBbYmF0Y2hVcGRhdGVTYXZlRGF0YV0pO1xuXG4gICAgY29uc3QgbG9hZFByb2R1Y3RTYXZlQ291bnQgPSBhc3luYyAocHJvZHVjdElkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFByb2R1Y3RTYXZlQ291bnQocHJvZHVjdElkKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcyAmJiByZXN1bHQuY291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNldFNhdmVDb3VudChwcm9kdWN0SWQsIHJlc3VsdC5jb3VudCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgc2F2ZSBjb3VudDonLCByZXN1bHQuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBzYXZlIGNvdW50OicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCB0b2dnbGVTYXZlID0gYXN5bmMgKHByb2R1Y3RJZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+ID0+IHtcbiAgICAgICAgc2V0TG9hZGluZyh0cnVlLCAnU2F2aW5nLi4uJyk7XG4gICAgICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpc0N1cnJlbnRseVNhdmVkID0gaXNQcm9kdWN0U2F2ZWRJblN0b3JlKHByb2R1Y3RJZCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGlzQ3VycmVudGx5U2F2ZWRcbiAgICAgICAgICAgICAgICA/IGF3YWl0IHVuc2F2ZVByb2R1Y3QocHJvZHVjdElkKVxuICAgICAgICAgICAgICAgIDogYXdhaXQgc2F2ZVByb2R1Y3QocHJvZHVjdElkKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudGx5U2F2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlU2F2ZWRQcm9kdWN0KHByb2R1Y3RJZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU2F2ZWRQcm9kdWN0KHByb2R1Y3RJZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zYXZlQ291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRTYXZlQ291bnQocHJvZHVjdElkLCByZXN1bHQuc2F2ZUNvdW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKHJlc3VsdC5lcnJvciB8fCAnRmFpbGVkIHRvIHNhdmUgcHJvZHVjdCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogcmVzdWx0LmVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAnRmFpbGVkIHRvIHNhdmUgcHJvZHVjdCc7XG4gICAgICAgICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvck1lc3NhZ2UgfTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEJhdGNoIHRvZ2dsZSBtdWx0aXBsZSBzYXZlc1xuICAgIGNvbnN0IGJhdGNoVG9nZ2xlU2F2ZXNBY3Rpb24gPSBhc3luYyAoXG4gICAgICAgIHByb2R1Y3RJZHM6IHN0cmluZ1tdLFxuICAgICAgICBhY3Rpb246ICdzYXZlJyB8ICd1bnNhdmUnXG4gICAgKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nOyByZXN1bHRzPzogYW55W10gfT4gPT4ge1xuICAgICAgICBzZXRMb2FkaW5nKHRydWUsIGAke2FjdGlvbiA9PT0gJ3NhdmUnID8gJ1NhdmluZycgOiAnUmVtb3ZpbmcnfSBwcm9kdWN0cy4uLmApO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYmF0Y2hUb2dnbGVTYXZlcyhwcm9kdWN0SWRzLCBhY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5yZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHN0b3JlIHdpdGggYmF0Y2ggcmVzdWx0c1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZXN1bHRzLmZvckVhY2goKHsgcHJvZHVjdElkLCBpc1NhdmVkLCBzYXZlQ291bnQgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTYXZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkU2F2ZWRQcm9kdWN0KHByb2R1Y3RJZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVTYXZlZFByb2R1Y3QocHJvZHVjdElkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRTYXZlQ291bnQocHJvZHVjdElkLCBzYXZlQ291bnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHJlc3VsdHM6IHJlc3VsdC5yZXN1bHRzIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKHJlc3VsdC5lcnJvciB8fCAnRmFpbGVkIHRvIGJhdGNoIHRvZ2dsZSBzYXZlcycpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogcmVzdWx0LmVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAnRmFpbGVkIHRvIGJhdGNoIHRvZ2dsZSBzYXZlcyc7XG4gICAgICAgICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvck1lc3NhZ2UgfTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGNoZWNrUHJvZHVjdFNhdmVTdGF0dXMgPSBhc3luYyAocHJvZHVjdElkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGlzUHJvZHVjdFNhdmVkKHByb2R1Y3RJZCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LmlzU2F2ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNTYXZlZCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRTYXZlZFByb2R1Y3QocHJvZHVjdElkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVTYXZlZFByb2R1Y3QocHJvZHVjdElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHNhdmUgc3RhdHVzOicsIHJlc3VsdC5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBzYXZlIHN0YXR1czonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gU3RhdGVcbiAgICAgICAgc2F2ZWRQcm9kdWN0czogQXJyYXkuZnJvbShzYXZlZFByb2R1Y3RzKSxcbiAgICAgICAgc2F2ZUNvdW50cyxcbiAgICAgICAgZXJyb3IsXG5cbiAgICAgICAgLy8gQWN0aW9uc1xuICAgICAgICB0b2dnbGVTYXZlLFxuICAgICAgICBiYXRjaFRvZ2dsZVNhdmVzOiBiYXRjaFRvZ2dsZVNhdmVzQWN0aW9uLFxuICAgICAgICBsb2FkUHJvZHVjdFNhdmVDb3VudCxcbiAgICAgICAgbG9hZFByb2R1Y3RzU2F2ZURhdGEsXG4gICAgICAgIGNoZWNrUHJvZHVjdFNhdmVTdGF0dXMsXG4gICAgICAgIGxvYWRVc2VyU2F2ZWRQcm9kdWN0cyxcbiAgICAgICAgY2xlYXJFcnJvcixcblxuICAgICAgICAvLyBIZWxwZXJzXG4gICAgICAgIGlzUHJvZHVjdFNhdmVkOiBpc1Byb2R1Y3RTYXZlZEluU3RvcmUsXG4gICAgICAgIGdldFNhdmVDb3VudDogZ2V0U2F2ZUNvdW50RnJvbVN0b3JlLFxuICAgIH07XG59XG5cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsInVzZVNhdmVTdG9yZSIsInVzZUxvYWRpbmdTdG9yZSIsInNhdmVQcm9kdWN0IiwidW5zYXZlUHJvZHVjdCIsImdldFVzZXJTYXZlZFByb2R1Y3RzIiwiZ2V0UHJvZHVjdFNhdmVDb3VudCIsImlzUHJvZHVjdFNhdmVkIiwiYmF0Y2hHZXRQcm9kdWN0c1NhdmVEYXRhIiwiYmF0Y2hUb2dnbGVTYXZlcyIsInVzZVNhdmVzIiwic2F2ZWRQcm9kdWN0cyIsInNhdmVDb3VudHMiLCJlcnJvciIsInNldFNhdmVkUHJvZHVjdHMiLCJhZGRTYXZlZFByb2R1Y3QiLCJyZW1vdmVTYXZlZFByb2R1Y3QiLCJzZXRTYXZlQ291bnQiLCJzZXRFcnJvciIsImlzUHJvZHVjdFNhdmVkSW5TdG9yZSIsImdldFNhdmVDb3VudCIsImdldFNhdmVDb3VudEZyb21TdG9yZSIsImNsZWFyRXJyb3IiLCJiYXRjaFVwZGF0ZVNhdmVEYXRhIiwic2V0TG9hZGluZyIsImxvYWRVc2VyU2F2ZWRQcm9kdWN0cyIsInJlc3VsdCIsInN1Y2Nlc3MiLCJwcm9kdWN0SWRzIiwibG9hZFByb2R1Y3RzU2F2ZURhdGEiLCJkYXRhIiwiY29uc29sZSIsImxvYWRQcm9kdWN0U2F2ZUNvdW50IiwicHJvZHVjdElkIiwiY291bnQiLCJ1bmRlZmluZWQiLCJ0b2dnbGVTYXZlIiwiaXNDdXJyZW50bHlTYXZlZCIsInNhdmVDb3VudCIsImVycm9yTWVzc2FnZSIsImJhdGNoVG9nZ2xlU2F2ZXNBY3Rpb24iLCJhY3Rpb24iLCJyZXN1bHRzIiwiZm9yRWFjaCIsImlzU2F2ZWQiLCJjaGVja1Byb2R1Y3RTYXZlU3RhdHVzIiwiQXJyYXkiLCJmcm9tIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useSaves.ts\n"));

/***/ })

});