"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/search/page",{

/***/ "(app-pages-browser)/./src/hooks/useSaves.ts":
/*!*******************************!*\
  !*** ./src/hooks/useSaves.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSavesEnhanced: () => (/* binding */ useSavesEnhanced)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _stores_saveStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/stores/saveStore */ \"(app-pages-browser)/./src/stores/saveStore.ts\");\n/* harmony import */ var _stores_loadingStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/stores/loadingStore */ \"(app-pages-browser)/./src/stores/loadingStore.ts\");\n/* harmony import */ var _lib_savesEnhanced__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/savesEnhanced */ \"(app-pages-browser)/./src/lib/savesEnhanced.ts\");\n\n\n\n\nfunction useSavesEnhanced() {\n    const { savedProducts, saveCounts, error, setSavedProducts, addSavedProduct, removeSavedProduct, setSaveCount, setError, isProductSaved: isProductSavedInStore, getSaveCount: getSaveCountFromStore, clearError, batchUpdateSaveData } = (0,_stores_saveStore__WEBPACK_IMPORTED_MODULE_1__.useSaveStore)();\n    const { setLoading } = (0,_stores_loadingStore__WEBPACK_IMPORTED_MODULE_2__.useLoadingStore)();\n    // Load user's saved products on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSavesEnhanced.useEffect\": ()=>{\n            loadUserSavedProducts();\n        }\n    }[\"useSavesEnhanced.useEffect\"], []);\n    const loadUserSavedProducts = async ()=>{\n        setLoading(true, 'Loading saved products...');\n        setError(null);\n        try {\n            const result = await (0,_lib_savesEnhanced__WEBPACK_IMPORTED_MODULE_3__.getUserSavedProducts)();\n            if (result.success && result.productIds) {\n                setSavedProducts(result.productIds);\n            } else if (result.error) {\n                setError(result.error);\n            }\n        } catch (error) {\n            setError('Failed to load saved products');\n        } finally{\n            setLoading(false);\n        }\n    };\n    // Batch load save data for multiple products\n    const loadProductsSaveData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSavesEnhanced.useCallback[loadProductsSaveData]\": async (productIds)=>{\n            try {\n                const result = await (0,_lib_savesEnhanced__WEBPACK_IMPORTED_MODULE_3__.batchGetProductsSaveData)(productIds);\n                if (result.success && result.data) {\n                    batchUpdateSaveData(result.data);\n                }\n            } catch (error) {\n                console.error('Error loading products save data:', error);\n            }\n        }\n    }[\"useSavesEnhanced.useCallback[loadProductsSaveData]\"], [\n        batchUpdateSaveData\n    ]);\n    const loadProductSaveCount = async (productId)=>{\n        try {\n            const result = await (0,_lib_savesEnhanced__WEBPACK_IMPORTED_MODULE_3__.getProductSaveCount)(productId);\n            if (result.success && result.count !== undefined) {\n                setSaveCount(productId, result.count);\n            }\n        } catch (error) {\n            console.error('Error loading save count:', error);\n        }\n    };\n    const toggleSave = async (productId)=>{\n        setLoading(true, 'Saving...');\n        setError(null);\n        try {\n            const isCurrentlySaved = isProductSavedInStore(productId);\n            const result = isCurrentlySaved ? await (0,_lib_savesEnhanced__WEBPACK_IMPORTED_MODULE_3__.unsaveProduct)(productId) : await (0,_lib_savesEnhanced__WEBPACK_IMPORTED_MODULE_3__.saveProduct)(productId);\n            if (result.success) {\n                if (isCurrentlySaved) {\n                    removeSavedProduct(productId);\n                } else {\n                    addSavedProduct(productId);\n                }\n                if (result.saveCount !== undefined) {\n                    setSaveCount(productId, result.saveCount);\n                }\n                return {\n                    success: true\n                };\n            } else {\n                setError(result.error || 'Failed to save product');\n                return {\n                    success: false,\n                    error: result.error\n                };\n            }\n        } catch (error) {\n            const errorMessage = 'Failed to save product';\n            setError(errorMessage);\n            return {\n                success: false,\n                error: errorMessage\n            };\n        } finally{\n            setLoading(false);\n        }\n    };\n    // Batch toggle multiple saves\n    const batchToggleSavesAction = async (productIds, action)=>{\n        setLoading(true, \"\".concat(action === 'save' ? 'Saving' : 'Removing', \" products...\"));\n        setError(null);\n        try {\n            const result = await (0,_lib_savesEnhanced__WEBPACK_IMPORTED_MODULE_3__.batchToggleSaves)(productIds, action);\n            if (result.success && result.results) {\n                // Update store with batch results\n                result.results.forEach((param)=>{\n                    let { productId, isSaved, saveCount } = param;\n                    if (isSaved) {\n                        addSavedProduct(productId);\n                    } else {\n                        removeSavedProduct(productId);\n                    }\n                    setSaveCount(productId, saveCount);\n                });\n                return {\n                    success: true,\n                    results: result.results\n                };\n            } else {\n                setError(result.error || 'Failed to batch toggle saves');\n                return {\n                    success: false,\n                    error: result.error\n                };\n            }\n        } catch (error) {\n            const errorMessage = 'Failed to batch toggle saves';\n            setError(errorMessage);\n            return {\n                success: false,\n                error: errorMessage\n            };\n        } finally{\n            setLoading(false);\n        }\n    };\n    const checkProductSaveStatus = async (productId)=>{\n        try {\n            const result = await (0,_lib_savesEnhanced__WEBPACK_IMPORTED_MODULE_3__.isProductSaved)(productId);\n            if (result.success && result.isSaved !== undefined) {\n                if (result.isSaved) {\n                    addSavedProduct(productId);\n                } else {\n                    removeSavedProduct(productId);\n                }\n            }\n        } catch (error) {\n            console.error('Error checking save status:', error);\n        }\n    };\n    return {\n        // State\n        savedProducts: Array.from(savedProducts),\n        saveCounts,\n        error,\n        // Actions\n        toggleSave,\n        batchToggleSaves: batchToggleSavesAction,\n        loadProductSaveCount,\n        loadProductsSaveData,\n        checkProductSaveStatus,\n        loadUserSavedProducts,\n        clearError,\n        // Helpers\n        isProductSaved: isProductSavedInStore,\n        getSaveCount: getSaveCountFromStore\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VTYXZlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0M7QUFDRztBQUNNO0FBUzNCO0FBRXRCLFNBQVNXO0lBQ1osTUFBTSxFQUNGQyxhQUFhLEVBQ2JDLFVBQVUsRUFDVkMsS0FBSyxFQUNMQyxnQkFBZ0IsRUFDaEJDLGVBQWUsRUFDZkMsa0JBQWtCLEVBQ2xCQyxZQUFZLEVBQ1pDLFFBQVEsRUFDUlgsZ0JBQWdCWSxxQkFBcUIsRUFDckNDLGNBQWNDLHFCQUFxQixFQUNuQ0MsVUFBVSxFQUNWQyxtQkFBbUIsRUFDdEIsR0FBR3RCLCtEQUFZQTtJQUVoQixNQUFNLEVBQUV1QixVQUFVLEVBQUUsR0FBR3RCLHFFQUFlQTtJQUV0QyxzQ0FBc0M7SUFDdENILGdEQUFTQTtzQ0FBQztZQUNOMEI7UUFDSjtxQ0FBRyxFQUFFO0lBRUwsTUFBTUEsd0JBQXdCO1FBQzFCRCxXQUFXLE1BQU07UUFDakJOLFNBQVM7UUFFVCxJQUFJO1lBQ0EsTUFBTVEsU0FBUyxNQUFNckIsd0VBQW9CQTtZQUN6QyxJQUFJcUIsT0FBT0MsT0FBTyxJQUFJRCxPQUFPRSxVQUFVLEVBQUU7Z0JBQ3JDZCxpQkFBaUJZLE9BQU9FLFVBQVU7WUFDdEMsT0FBTyxJQUFJRixPQUFPYixLQUFLLEVBQUU7Z0JBQ3JCSyxTQUFTUSxPQUFPYixLQUFLO1lBQ3pCO1FBQ0osRUFBRSxPQUFPQSxPQUFPO1lBQ1pLLFNBQVM7UUFDYixTQUFVO1lBQ05NLFdBQVc7UUFDZjtJQUNKO0lBRUEsNkNBQTZDO0lBQzdDLE1BQU1LLHVCQUF1QjdCLGtEQUFXQTs4REFBQyxPQUFPNEI7WUFDNUMsSUFBSTtnQkFDQSxNQUFNRixTQUFTLE1BQU1sQiw0RUFBd0JBLENBQUNvQjtnQkFDOUMsSUFBSUYsT0FBT0MsT0FBTyxJQUFJRCxPQUFPSSxJQUFJLEVBQUU7b0JBQy9CUCxvQkFBb0JHLE9BQU9JLElBQUk7Z0JBQ25DO1lBQ0osRUFBRSxPQUFPakIsT0FBTztnQkFDWmtCLFFBQVFsQixLQUFLLENBQUMscUNBQXFDQTtZQUN2RDtRQUNKOzZEQUFHO1FBQUNVO0tBQW9CO0lBRXhCLE1BQU1TLHVCQUF1QixPQUFPQztRQUNoQyxJQUFJO1lBQ0EsTUFBTVAsU0FBUyxNQUFNcEIsdUVBQW1CQSxDQUFDMkI7WUFDekMsSUFBSVAsT0FBT0MsT0FBTyxJQUFJRCxPQUFPUSxLQUFLLEtBQUtDLFdBQVc7Z0JBQzlDbEIsYUFBYWdCLFdBQVdQLE9BQU9RLEtBQUs7WUFDeEM7UUFDSixFQUFFLE9BQU9yQixPQUFPO1lBQ1prQixRQUFRbEIsS0FBSyxDQUFDLDZCQUE2QkE7UUFDL0M7SUFDSjtJQUVBLE1BQU11QixhQUFhLE9BQU9IO1FBQ3RCVCxXQUFXLE1BQU07UUFDakJOLFNBQVM7UUFFVCxJQUFJO1lBQ0EsTUFBTW1CLG1CQUFtQmxCLHNCQUFzQmM7WUFFL0MsTUFBTVAsU0FBU1csbUJBQ1QsTUFBTWpDLGlFQUFhQSxDQUFDNkIsYUFDcEIsTUFBTTlCLCtEQUFXQSxDQUFDOEI7WUFFeEIsSUFBSVAsT0FBT0MsT0FBTyxFQUFFO2dCQUNoQixJQUFJVSxrQkFBa0I7b0JBQ2xCckIsbUJBQW1CaUI7Z0JBQ3ZCLE9BQU87b0JBQ0hsQixnQkFBZ0JrQjtnQkFDcEI7Z0JBRUEsSUFBSVAsT0FBT1ksU0FBUyxLQUFLSCxXQUFXO29CQUNoQ2xCLGFBQWFnQixXQUFXUCxPQUFPWSxTQUFTO2dCQUM1QztnQkFFQSxPQUFPO29CQUFFWCxTQUFTO2dCQUFLO1lBQzNCLE9BQU87Z0JBQ0hULFNBQVNRLE9BQU9iLEtBQUssSUFBSTtnQkFDekIsT0FBTztvQkFBRWMsU0FBUztvQkFBT2QsT0FBT2EsT0FBT2IsS0FBSztnQkFBQztZQUNqRDtRQUNKLEVBQUUsT0FBT0EsT0FBTztZQUNaLE1BQU0wQixlQUFlO1lBQ3JCckIsU0FBU3FCO1lBQ1QsT0FBTztnQkFBRVosU0FBUztnQkFBT2QsT0FBTzBCO1lBQWE7UUFDakQsU0FBVTtZQUNOZixXQUFXO1FBQ2Y7SUFDSjtJQUVBLDhCQUE4QjtJQUM5QixNQUFNZ0IseUJBQXlCLE9BQzNCWixZQUNBYTtRQUVBakIsV0FBVyxNQUFNLEdBQTZDLE9BQTFDaUIsV0FBVyxTQUFTLFdBQVcsWUFBVztRQUM5RHZCLFNBQVM7UUFFVCxJQUFJO1lBQ0EsTUFBTVEsU0FBUyxNQUFNakIsb0VBQWdCQSxDQUFDbUIsWUFBWWE7WUFDbEQsSUFBSWYsT0FBT0MsT0FBTyxJQUFJRCxPQUFPZ0IsT0FBTyxFQUFFO2dCQUNsQyxrQ0FBa0M7Z0JBQ2xDaEIsT0FBT2dCLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDO3dCQUFDLEVBQUVWLFNBQVMsRUFBRVcsT0FBTyxFQUFFTixTQUFTLEVBQUU7b0JBQ3JELElBQUlNLFNBQVM7d0JBQ1Q3QixnQkFBZ0JrQjtvQkFDcEIsT0FBTzt3QkFDSGpCLG1CQUFtQmlCO29CQUN2QjtvQkFDQWhCLGFBQWFnQixXQUFXSztnQkFDNUI7Z0JBQ0EsT0FBTztvQkFBRVgsU0FBUztvQkFBTWUsU0FBU2hCLE9BQU9nQixPQUFPO2dCQUFDO1lBQ3BELE9BQU87Z0JBQ0h4QixTQUFTUSxPQUFPYixLQUFLLElBQUk7Z0JBQ3pCLE9BQU87b0JBQUVjLFNBQVM7b0JBQU9kLE9BQU9hLE9BQU9iLEtBQUs7Z0JBQUM7WUFDakQ7UUFDSixFQUFFLE9BQU9BLE9BQU87WUFDWixNQUFNMEIsZUFBZTtZQUNyQnJCLFNBQVNxQjtZQUNULE9BQU87Z0JBQUVaLFNBQVM7Z0JBQU9kLE9BQU8wQjtZQUFhO1FBQ2pELFNBQVU7WUFDTmYsV0FBVztRQUNmO0lBQ0o7SUFFQSxNQUFNcUIseUJBQXlCLE9BQU9aO1FBQ2xDLElBQUk7WUFDQSxNQUFNUCxTQUFTLE1BQU1uQixrRUFBY0EsQ0FBQzBCO1lBQ3BDLElBQUlQLE9BQU9DLE9BQU8sSUFBSUQsT0FBT2tCLE9BQU8sS0FBS1QsV0FBVztnQkFDaEQsSUFBSVQsT0FBT2tCLE9BQU8sRUFBRTtvQkFDaEI3QixnQkFBZ0JrQjtnQkFDcEIsT0FBTztvQkFDSGpCLG1CQUFtQmlCO2dCQUN2QjtZQUNKO1FBQ0osRUFBRSxPQUFPcEIsT0FBTztZQUNaa0IsUUFBUWxCLEtBQUssQ0FBQywrQkFBK0JBO1FBQ2pEO0lBQ0o7SUFFQSxPQUFPO1FBQ0gsUUFBUTtRQUNSRixlQUFlbUMsTUFBTUMsSUFBSSxDQUFDcEM7UUFDMUJDO1FBQ0FDO1FBRUEsVUFBVTtRQUNWdUI7UUFDQTNCLGtCQUFrQitCO1FBQ2xCUjtRQUNBSDtRQUNBZ0I7UUFDQXBCO1FBQ0FIO1FBRUEsVUFBVTtRQUNWZixnQkFBZ0JZO1FBQ2hCQyxjQUFjQztJQUNsQjtBQUNKIiwic291cmNlcyI6WyIvVXNlcnMvaWZlZGF5b2FnYm9vbGEvRGVza3RvcC9teVByb2plY3RzL2V0aG5pcXJvb3R6LW5leHRqcy9zcmMvaG9va3MvdXNlU2F2ZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVNhdmVTdG9yZSB9IGZyb20gJ0Avc3RvcmVzL3NhdmVTdG9yZSc7XG5pbXBvcnQgeyB1c2VMb2FkaW5nU3RvcmUgfSBmcm9tICdAL3N0b3Jlcy9sb2FkaW5nU3RvcmUnO1xuaW1wb3J0IHtcbiAgICBzYXZlUHJvZHVjdCxcbiAgICB1bnNhdmVQcm9kdWN0LFxuICAgIGdldFVzZXJTYXZlZFByb2R1Y3RzLFxuICAgIGdldFByb2R1Y3RTYXZlQ291bnQsXG4gICAgaXNQcm9kdWN0U2F2ZWQsXG4gICAgYmF0Y2hHZXRQcm9kdWN0c1NhdmVEYXRhLFxuICAgIGJhdGNoVG9nZ2xlU2F2ZXNcbn0gZnJvbSAnQC9saWIvc2F2ZXNFbmhhbmNlZCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTYXZlc0VuaGFuY2VkKCkge1xuICAgIGNvbnN0IHtcbiAgICAgICAgc2F2ZWRQcm9kdWN0cyxcbiAgICAgICAgc2F2ZUNvdW50cyxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHNldFNhdmVkUHJvZHVjdHMsXG4gICAgICAgIGFkZFNhdmVkUHJvZHVjdCxcbiAgICAgICAgcmVtb3ZlU2F2ZWRQcm9kdWN0LFxuICAgICAgICBzZXRTYXZlQ291bnQsXG4gICAgICAgIHNldEVycm9yLFxuICAgICAgICBpc1Byb2R1Y3RTYXZlZDogaXNQcm9kdWN0U2F2ZWRJblN0b3JlLFxuICAgICAgICBnZXRTYXZlQ291bnQ6IGdldFNhdmVDb3VudEZyb21TdG9yZSxcbiAgICAgICAgY2xlYXJFcnJvcixcbiAgICAgICAgYmF0Y2hVcGRhdGVTYXZlRGF0YSxcbiAgICB9ID0gdXNlU2F2ZVN0b3JlKCk7XG5cbiAgICBjb25zdCB7IHNldExvYWRpbmcgfSA9IHVzZUxvYWRpbmdTdG9yZSgpO1xuXG4gICAgLy8gTG9hZCB1c2VyJ3Mgc2F2ZWQgcHJvZHVjdHMgb24gbW91bnRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsb2FkVXNlclNhdmVkUHJvZHVjdHMoKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBsb2FkVXNlclNhdmVkUHJvZHVjdHMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHNldExvYWRpbmcodHJ1ZSwgJ0xvYWRpbmcgc2F2ZWQgcHJvZHVjdHMuLi4nKTtcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJTYXZlZFByb2R1Y3RzKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LnByb2R1Y3RJZHMpIHtcbiAgICAgICAgICAgICAgICBzZXRTYXZlZFByb2R1Y3RzKHJlc3VsdC5wcm9kdWN0SWRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IocmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gbG9hZCBzYXZlZCBwcm9kdWN0cycpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQmF0Y2ggbG9hZCBzYXZlIGRhdGEgZm9yIG11bHRpcGxlIHByb2R1Y3RzXG4gICAgY29uc3QgbG9hZFByb2R1Y3RzU2F2ZURhdGEgPSB1c2VDYWxsYmFjayhhc3luYyAocHJvZHVjdElkczogc3RyaW5nW10pID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJhdGNoR2V0UHJvZHVjdHNTYXZlRGF0YShwcm9kdWN0SWRzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcyAmJiByZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgICAgIGJhdGNoVXBkYXRlU2F2ZURhdGEocmVzdWx0LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBwcm9kdWN0cyBzYXZlIGRhdGE6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSwgW2JhdGNoVXBkYXRlU2F2ZURhdGFdKTtcblxuICAgIGNvbnN0IGxvYWRQcm9kdWN0U2F2ZUNvdW50ID0gYXN5bmMgKHByb2R1Y3RJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRQcm9kdWN0U2F2ZUNvdW50KHByb2R1Y3RJZCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LmNvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRTYXZlQ291bnQocHJvZHVjdElkLCByZXN1bHQuY291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBzYXZlIGNvdW50OicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCB0b2dnbGVTYXZlID0gYXN5bmMgKHByb2R1Y3RJZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+ID0+IHtcbiAgICAgICAgc2V0TG9hZGluZyh0cnVlLCAnU2F2aW5nLi4uJyk7XG4gICAgICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpc0N1cnJlbnRseVNhdmVkID0gaXNQcm9kdWN0U2F2ZWRJblN0b3JlKHByb2R1Y3RJZCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGlzQ3VycmVudGx5U2F2ZWRcbiAgICAgICAgICAgICAgICA/IGF3YWl0IHVuc2F2ZVByb2R1Y3QocHJvZHVjdElkKVxuICAgICAgICAgICAgICAgIDogYXdhaXQgc2F2ZVByb2R1Y3QocHJvZHVjdElkKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQ3VycmVudGx5U2F2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlU2F2ZWRQcm9kdWN0KHByb2R1Y3RJZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU2F2ZWRQcm9kdWN0KHByb2R1Y3RJZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zYXZlQ291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRTYXZlQ291bnQocHJvZHVjdElkLCByZXN1bHQuc2F2ZUNvdW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKHJlc3VsdC5lcnJvciB8fCAnRmFpbGVkIHRvIHNhdmUgcHJvZHVjdCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogcmVzdWx0LmVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAnRmFpbGVkIHRvIHNhdmUgcHJvZHVjdCc7XG4gICAgICAgICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvck1lc3NhZ2UgfTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEJhdGNoIHRvZ2dsZSBtdWx0aXBsZSBzYXZlc1xuICAgIGNvbnN0IGJhdGNoVG9nZ2xlU2F2ZXNBY3Rpb24gPSBhc3luYyAoXG4gICAgICAgIHByb2R1Y3RJZHM6IHN0cmluZ1tdLFxuICAgICAgICBhY3Rpb246ICdzYXZlJyB8ICd1bnNhdmUnXG4gICAgKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nOyByZXN1bHRzPzogYW55W10gfT4gPT4ge1xuICAgICAgICBzZXRMb2FkaW5nKHRydWUsIGAke2FjdGlvbiA9PT0gJ3NhdmUnID8gJ1NhdmluZycgOiAnUmVtb3ZpbmcnfSBwcm9kdWN0cy4uLmApO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYmF0Y2hUb2dnbGVTYXZlcyhwcm9kdWN0SWRzLCBhY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5yZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHN0b3JlIHdpdGggYmF0Y2ggcmVzdWx0c1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZXN1bHRzLmZvckVhY2goKHsgcHJvZHVjdElkLCBpc1NhdmVkLCBzYXZlQ291bnQgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTYXZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkU2F2ZWRQcm9kdWN0KHByb2R1Y3RJZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVTYXZlZFByb2R1Y3QocHJvZHVjdElkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRTYXZlQ291bnQocHJvZHVjdElkLCBzYXZlQ291bnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHJlc3VsdHM6IHJlc3VsdC5yZXN1bHRzIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKHJlc3VsdC5lcnJvciB8fCAnRmFpbGVkIHRvIGJhdGNoIHRvZ2dsZSBzYXZlcycpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogcmVzdWx0LmVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAnRmFpbGVkIHRvIGJhdGNoIHRvZ2dsZSBzYXZlcyc7XG4gICAgICAgICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvck1lc3NhZ2UgfTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGNoZWNrUHJvZHVjdFNhdmVTdGF0dXMgPSBhc3luYyAocHJvZHVjdElkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGlzUHJvZHVjdFNhdmVkKHByb2R1Y3RJZCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LmlzU2F2ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNTYXZlZCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRTYXZlZFByb2R1Y3QocHJvZHVjdElkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVTYXZlZFByb2R1Y3QocHJvZHVjdElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBzYXZlIHN0YXR1czonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gU3RhdGVcbiAgICAgICAgc2F2ZWRQcm9kdWN0czogQXJyYXkuZnJvbShzYXZlZFByb2R1Y3RzKSxcbiAgICAgICAgc2F2ZUNvdW50cyxcbiAgICAgICAgZXJyb3IsXG5cbiAgICAgICAgLy8gQWN0aW9uc1xuICAgICAgICB0b2dnbGVTYXZlLFxuICAgICAgICBiYXRjaFRvZ2dsZVNhdmVzOiBiYXRjaFRvZ2dsZVNhdmVzQWN0aW9uLFxuICAgICAgICBsb2FkUHJvZHVjdFNhdmVDb3VudCxcbiAgICAgICAgbG9hZFByb2R1Y3RzU2F2ZURhdGEsXG4gICAgICAgIGNoZWNrUHJvZHVjdFNhdmVTdGF0dXMsXG4gICAgICAgIGxvYWRVc2VyU2F2ZWRQcm9kdWN0cyxcbiAgICAgICAgY2xlYXJFcnJvcixcblxuICAgICAgICAvLyBIZWxwZXJzXG4gICAgICAgIGlzUHJvZHVjdFNhdmVkOiBpc1Byb2R1Y3RTYXZlZEluU3RvcmUsXG4gICAgICAgIGdldFNhdmVDb3VudDogZ2V0U2F2ZUNvdW50RnJvbVN0b3JlLFxuICAgIH07XG59XG5cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsInVzZVNhdmVTdG9yZSIsInVzZUxvYWRpbmdTdG9yZSIsInNhdmVQcm9kdWN0IiwidW5zYXZlUHJvZHVjdCIsImdldFVzZXJTYXZlZFByb2R1Y3RzIiwiZ2V0UHJvZHVjdFNhdmVDb3VudCIsImlzUHJvZHVjdFNhdmVkIiwiYmF0Y2hHZXRQcm9kdWN0c1NhdmVEYXRhIiwiYmF0Y2hUb2dnbGVTYXZlcyIsInVzZVNhdmVzRW5oYW5jZWQiLCJzYXZlZFByb2R1Y3RzIiwic2F2ZUNvdW50cyIsImVycm9yIiwic2V0U2F2ZWRQcm9kdWN0cyIsImFkZFNhdmVkUHJvZHVjdCIsInJlbW92ZVNhdmVkUHJvZHVjdCIsInNldFNhdmVDb3VudCIsInNldEVycm9yIiwiaXNQcm9kdWN0U2F2ZWRJblN0b3JlIiwiZ2V0U2F2ZUNvdW50IiwiZ2V0U2F2ZUNvdW50RnJvbVN0b3JlIiwiY2xlYXJFcnJvciIsImJhdGNoVXBkYXRlU2F2ZURhdGEiLCJzZXRMb2FkaW5nIiwibG9hZFVzZXJTYXZlZFByb2R1Y3RzIiwicmVzdWx0Iiwic3VjY2VzcyIsInByb2R1Y3RJZHMiLCJsb2FkUHJvZHVjdHNTYXZlRGF0YSIsImRhdGEiLCJjb25zb2xlIiwibG9hZFByb2R1Y3RTYXZlQ291bnQiLCJwcm9kdWN0SWQiLCJjb3VudCIsInVuZGVmaW5lZCIsInRvZ2dsZVNhdmUiLCJpc0N1cnJlbnRseVNhdmVkIiwic2F2ZUNvdW50IiwiZXJyb3JNZXNzYWdlIiwiYmF0Y2hUb2dnbGVTYXZlc0FjdGlvbiIsImFjdGlvbiIsInJlc3VsdHMiLCJmb3JFYWNoIiwiaXNTYXZlZCIsImNoZWNrUHJvZHVjdFNhdmVTdGF0dXMiLCJBcnJheSIsImZyb20iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useSaves.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/savesEnhanced.ts":
/*!**********************************!*\
  !*** ./src/lib/savesEnhanced.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   batchGetProductsSaveData: () => (/* binding */ batchGetProductsSaveData),\n/* harmony export */   batchToggleSaves: () => (/* binding */ batchToggleSaves),\n/* harmony export */   clearSaveCache: () => (/* binding */ clearSaveCache),\n/* harmony export */   getProductSaveCount: () => (/* binding */ getProductSaveCount),\n/* harmony export */   getUserSavedProducts: () => (/* binding */ getUserSavedProducts),\n/* harmony export */   getUserSavedProductsWithMetadata: () => (/* binding */ getUserSavedProductsWithMetadata),\n/* harmony export */   isProductSaved: () => (/* binding */ isProductSaved),\n/* harmony export */   saveProduct: () => (/* binding */ saveProduct),\n/* harmony export */   unsaveProduct: () => (/* binding */ unsaveProduct)\n/* harmony export */ });\n/* harmony import */ var _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/integrations/supabase/client */ \"(app-pages-browser)/./src/integrations/supabase/client.ts\");\n\n// Request throttling and caching\nconst requestCache = new Map();\nconst pendingRequests = new Map();\nconst REQUEST_CACHE_DURATION = 30000; // 30 seconds\nconst REQUEST_THROTTLE_DELAY = 1000; // 1 second between requests\n// Throttled request helper with retry logic\nasync function throttledRequest(key, requestFn) {\n    let useCache = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true, maxRetries = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 2;\n    // Check cache first\n    if (useCache) {\n        const cached = requestCache.get(key);\n        if (cached && Date.now() - cached.timestamp < REQUEST_CACHE_DURATION) {\n            return cached.data;\n        }\n    }\n    // Check if request is already pending\n    if (pendingRequests.has(key)) {\n        return pendingRequests.get(key);\n    }\n    // Create new request with retry logic\n    const requestPromise = new Promise(async (resolve, reject)=>{\n        let attempts = 0;\n        const attemptRequest = async ()=>{\n            try {\n                attempts++;\n                const result = await requestFn();\n                if (useCache) {\n                    requestCache.set(key, {\n                        data: result,\n                        timestamp: Date.now()\n                    });\n                }\n                resolve(result);\n            } catch (error) {\n                if (attempts < maxRetries && shouldRetry(error)) {\n                    // Exponential backoff: 500ms, 1000ms, 2000ms\n                    const delay = 500 * Math.pow(2, attempts - 1);\n                    setTimeout(attemptRequest, delay);\n                } else {\n                    reject(error);\n                }\n            } finally{\n                if (attempts >= maxRetries) {\n                    pendingRequests.delete(key);\n                }\n            }\n        };\n        // Initial delay for throttling\n        setTimeout(attemptRequest, REQUEST_THROTTLE_DELAY);\n    });\n    pendingRequests.set(key, requestPromise);\n    return requestPromise;\n}\n// Helper to determine if an error should trigger a retry\nfunction shouldRetry(error) {\n    var _error_message;\n    if (!error) return false;\n    // Retry on network errors or connection issues\n    const message = ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.toLowerCase()) || '';\n    return message.includes('network') || message.includes('connection') || message.includes('timeout') || message.includes('err_connection_closed') || message.includes('err_failed');\n}\n// Cache invalidation helper\nfunction invalidateCache(pattern) {\n    const keysToDelete = [];\n    requestCache.forEach((_, key)=>{\n        if (key.includes(pattern)) {\n            keysToDelete.push(key);\n        }\n    });\n    keysToDelete.forEach((key)=>requestCache.delete(key));\n}\n// Clear all cache (useful for logout or major state changes)\nfunction clearSaveCache() {\n    requestCache.clear();\n    pendingRequests.clear();\n}\n// Enhanced client-side save operations with better error handling and performance\nasync function saveProduct(productId) {\n    try {\n        const { data: { user } } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) {\n            return {\n                success: false,\n                error: 'User not authenticated'\n            };\n        }\n        const { error } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('saves').insert({\n            user_id: user.id,\n            product_id: productId\n        });\n        if (error) {\n            // Handle unique constraint violation gracefully\n            if (error.code === '23505') {\n                return {\n                    success: true,\n                    saveCount: 0\n                }; // Already saved\n            }\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n        // Invalidate cache for this product\n        invalidateCache(productId);\n        // Get updated save count\n        const { data: countData, error: countError } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc('get_product_save_count', {\n            product_uuid: productId\n        });\n        if (countError) {\n            console.error('Error getting save count:', countError);\n        }\n        return {\n            success: true,\n            saveCount: countData || 0\n        };\n    } catch (error) {\n        console.error('Error saving product:', error);\n        return {\n            success: false,\n            error: 'Failed to save product'\n        };\n    }\n}\nasync function unsaveProduct(productId) {\n    try {\n        const { data: { user } } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) {\n            return {\n                success: false,\n                error: 'User not authenticated'\n            };\n        }\n        const { error } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('saves').delete().eq('product_id', productId).eq('user_id', user.id);\n        if (error) {\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n        // Invalidate cache for this product\n        invalidateCache(productId);\n        // Get updated save count\n        const { data: countData, error: countError } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc('get_product_save_count', {\n            product_uuid: productId\n        });\n        if (countError) {\n            console.error('Error getting save count:', countError);\n        }\n        return {\n            success: true,\n            saveCount: countData || 0\n        };\n    } catch (error) {\n        console.error('Error unsaving product:', error);\n        return {\n            success: false,\n            error: 'Failed to unsave product'\n        };\n    }\n}\nasync function getUserSavedProducts() {\n    try {\n        const { data: { user } } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) {\n            return {\n                success: false,\n                error: 'User not authenticated'\n            };\n        }\n        const { data, error } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('saves').select('product_id').eq('user_id', user.id).order('created_at', {\n            ascending: false\n        });\n        if (error) {\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n        const productIds = (data === null || data === void 0 ? void 0 : data.map((item)=>item.product_id)) || [];\n        return {\n            success: true,\n            productIds\n        };\n    } catch (error) {\n        console.error('Error getting saved products:', error);\n        return {\n            success: false,\n            error: 'Failed to get saved products'\n        };\n    }\n}\nasync function getProductSaveCount(productId) {\n    const cacheKey = \"save_count_\".concat(productId);\n    return throttledRequest(cacheKey, async ()=>{\n        try {\n            const { data, error } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc('get_product_save_count', {\n                product_uuid: productId\n            });\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true,\n                count: data || 0\n            };\n        } catch (error) {\n            console.error('Error getting save count:', error);\n            return {\n                success: false,\n                error: 'Failed to get save count'\n            };\n        }\n    });\n}\nasync function isProductSaved(productId) {\n    const { data: { user } } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n    if (!user) {\n        return {\n            success: false,\n            error: 'User not authenticated'\n        };\n    }\n    const cacheKey = \"is_saved_\".concat(productId, \"_\").concat(user.id);\n    return throttledRequest(cacheKey, async ()=>{\n        try {\n            const { data, error } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc('is_product_saved_by_user', {\n                product_uuid: productId,\n                user_uuid: user.id\n            });\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true,\n                isSaved: data || false\n            };\n        } catch (error) {\n            console.error('Error checking if product is saved:', error);\n            return {\n                success: false,\n                error: 'Failed to check save status'\n            };\n        }\n    });\n}\n// NEW: Batch operations for better performance\nasync function batchGetProductsSaveData(productIds) {\n    try {\n        const { data: { user } } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) {\n            return {\n                success: false,\n                error: 'User not authenticated'\n            };\n        }\n        const { data, error } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc('get_products_save_data', {\n            product_uuids: productIds,\n            user_uuid: user.id\n        });\n        if (error) {\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n        const saveData = (data === null || data === void 0 ? void 0 : data.map((item)=>({\n                productId: item.product_id,\n                isSaved: item.is_saved,\n                saveCount: item.save_count\n            }))) || [];\n        return {\n            success: true,\n            data: saveData\n        };\n    } catch (error) {\n        console.error('Error getting batch save data:', error);\n        return {\n            success: false,\n            error: 'Failed to get batch save data'\n        };\n    }\n}\nasync function batchToggleSaves(productIds, action) {\n    try {\n        const { data: { user } } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) {\n            return {\n                success: false,\n                error: 'User not authenticated'\n            };\n        }\n        const { data, error } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc('batch_toggle_saves', {\n            product_uuids: productIds,\n            user_uuid: user.id,\n            action: action\n        });\n        if (error) {\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n        const results = (data === null || data === void 0 ? void 0 : data.map((item)=>({\n                productId: item.product_id,\n                isSaved: action === 'save',\n                saveCount: item.new_save_count\n            }))) || [];\n        return {\n            success: true,\n            results\n        };\n    } catch (error) {\n        console.error('Error batch toggling saves:', error);\n        return {\n            success: false,\n            error: 'Failed to batch toggle saves'\n        };\n    }\n}\n// NEW: Get saved products with metadata for a dedicated saved page\nasync function getUserSavedProductsWithMetadata() {\n    try {\n        const { data: { user } } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) {\n            return {\n                success: false,\n                error: 'User not authenticated'\n            };\n        }\n        const { data, error } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc('get_user_saved_products_with_metadata', {\n            user_uuid: user.id\n        });\n        if (error) {\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n        const products = (data === null || data === void 0 ? void 0 : data.map((item)=>({\n                productId: item.product_id,\n                savedAt: item.saved_at,\n                productTitle: item.product_title,\n                productPricePence: item.product_price_pence,\n                productImages: item.product_images || []\n            }))) || [];\n        return {\n            success: true,\n            products\n        };\n    } catch (error) {\n        console.error('Error getting saved products with metadata:', error);\n        return {\n            success: false,\n            error: 'Failed to get saved products with metadata'\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2F2ZXNFbmhhbmNlZC50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTBEO0FBRTFELGlDQUFpQztBQUNqQyxNQUFNQyxlQUFlLElBQUlDO0FBQ3pCLE1BQU1DLGtCQUFrQixJQUFJRDtBQUM1QixNQUFNRSx5QkFBeUIsT0FBTyxhQUFhO0FBQ25ELE1BQU1DLHlCQUF5QixNQUFNLDRCQUE0QjtBQUVqRSw0Q0FBNEM7QUFDNUMsZUFBZUMsaUJBQ1hDLEdBQVcsRUFDWEMsU0FBMkI7UUFDM0JDLFdBQUFBLGlFQUFvQixNQUNwQkMsYUFBQUEsaUVBQXFCO0lBRXJCLG9CQUFvQjtJQUNwQixJQUFJRCxVQUFVO1FBQ1YsTUFBTUUsU0FBU1YsYUFBYVcsR0FBRyxDQUFDTDtRQUNoQyxJQUFJSSxVQUFVRSxLQUFLQyxHQUFHLEtBQUtILE9BQU9JLFNBQVMsR0FBR1gsd0JBQXdCO1lBQ2xFLE9BQU9PLE9BQU9LLElBQUk7UUFDdEI7SUFDSjtJQUVBLHNDQUFzQztJQUN0QyxJQUFJYixnQkFBZ0JjLEdBQUcsQ0FBQ1YsTUFBTTtRQUMxQixPQUFPSixnQkFBZ0JTLEdBQUcsQ0FBQ0w7SUFDL0I7SUFFQSxzQ0FBc0M7SUFDdEMsTUFBTVcsaUJBQWlCLElBQUlDLFFBQVcsT0FBT0MsU0FBU0M7UUFDbEQsSUFBSUMsV0FBVztRQUVmLE1BQU1DLGlCQUFpQjtZQUNuQixJQUFJO2dCQUNBRDtnQkFDQSxNQUFNRSxTQUFTLE1BQU1oQjtnQkFDckIsSUFBSUMsVUFBVTtvQkFDVlIsYUFBYXdCLEdBQUcsQ0FBQ2xCLEtBQUs7d0JBQUVTLE1BQU1RO3dCQUFRVCxXQUFXRixLQUFLQyxHQUFHO29CQUFHO2dCQUNoRTtnQkFDQU0sUUFBUUk7WUFDWixFQUFFLE9BQU9FLE9BQU87Z0JBQ1osSUFBSUosV0FBV1osY0FBY2lCLFlBQVlELFFBQVE7b0JBQzdDLDZDQUE2QztvQkFDN0MsTUFBTUUsUUFBUSxNQUFNQyxLQUFLQyxHQUFH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QzdELE9BQU87WUFDSHVCLFNBQVM7WUFDVHZCLE9BQU87UUFDWDtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pZmVkYXlvYWdib29sYS9EZXNrdG9wL215UHJvamVjdHMvZXRobmlxcm9vdHotbmV4dGpzL3NyYy9saWIvc2F2ZXNFbmhhbmNlZC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJ0AvaW50ZWdyYXRpb25zL3N1cGFiYXNlL2NsaWVudCc7XG5cbi8vIFJlcXVlc3QgdGhyb3R0bGluZyBhbmQgY2FjaGluZ1xuY29uc3QgcmVxdWVzdENhY2hlID0gbmV3IE1hcDxzdHJpbmcsIHsgZGF0YTogYW55OyB0aW1lc3RhbXA6IG51bWJlciB9PigpO1xuY29uc3QgcGVuZGluZ1JlcXVlc3RzID0gbmV3IE1hcDxzdHJpbmcsIFByb21pc2U8YW55Pj4oKTtcbmNvbnN0IFJFUVVFU1RfQ0FDSEVfRFVSQVRJT04gPSAzMDAwMDsgLy8gMzAgc2Vjb25kc1xuY29uc3QgUkVRVUVTVF9USFJPVFRMRV9ERUxBWSA9IDEwMDA7IC8vIDEgc2Vjb25kIGJldHdlZW4gcmVxdWVzdHNcblxuLy8gVGhyb3R0bGVkIHJlcXVlc3QgaGVscGVyIHdpdGggcmV0cnkgbG9naWNcbmFzeW5jIGZ1bmN0aW9uIHRocm90dGxlZFJlcXVlc3Q8VD4oXG4gICAga2V5OiBzdHJpbmcsXG4gICAgcmVxdWVzdEZuOiAoKSA9PiBQcm9taXNlPFQ+LFxuICAgIHVzZUNhY2hlOiBib29sZWFuID0gdHJ1ZSxcbiAgICBtYXhSZXRyaWVzOiBudW1iZXIgPSAyXG4pOiBQcm9taXNlPFQ+IHtcbiAgICAvLyBDaGVjayBjYWNoZSBmaXJzdFxuICAgIGlmICh1c2VDYWNoZSkge1xuICAgICAgICBjb25zdCBjYWNoZWQgPSByZXF1ZXN0Q2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIGlmIChjYWNoZWQgJiYgRGF0ZS5ub3coKSAtIGNhY2hlZC50aW1lc3RhbXAgPCBSRVFVRVNUX0NBQ0hFX0RVUkFUSU9OKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkLmRhdGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiByZXF1ZXN0IGlzIGFscmVhZHkgcGVuZGluZ1xuICAgIGlmIChwZW5kaW5nUmVxdWVzdHMuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0cy5nZXQoa2V5KSE7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG5ldyByZXF1ZXN0IHdpdGggcmV0cnkgbG9naWNcbiAgICBjb25zdCByZXF1ZXN0UHJvbWlzZSA9IG5ldyBQcm9taXNlPFQ+KGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgbGV0IGF0dGVtcHRzID0gMDtcblxuICAgICAgICBjb25zdCBhdHRlbXB0UmVxdWVzdCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdHMrKztcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXF1ZXN0Rm4oKTtcbiAgICAgICAgICAgICAgICBpZiAodXNlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdENhY2hlLnNldChrZXksIHsgZGF0YTogcmVzdWx0LCB0aW1lc3RhbXA6IERhdGUubm93KCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dGVtcHRzIDwgbWF4UmV0cmllcyAmJiBzaG91bGRSZXRyeShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwb25lbnRpYWwgYmFja29mZjogNTAwbXMsIDEwMDBtcywgMjAwMG1zXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gNTAwICogTWF0aC5wb3coMiwgYXR0ZW1wdHMgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChhdHRlbXB0UmVxdWVzdCwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdHMgPj0gbWF4UmV0cmllcykge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nUmVxdWVzdHMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEluaXRpYWwgZGVsYXkgZm9yIHRocm90dGxpbmdcbiAgICAgICAgc2V0VGltZW91dChhdHRlbXB0UmVxdWVzdCwgUkVRVUVTVF9USFJPVFRMRV9ERUxBWSk7XG4gICAgfSk7XG5cbiAgICBwZW5kaW5nUmVxdWVzdHMuc2V0KGtleSwgcmVxdWVzdFByb21pc2UpO1xuICAgIHJldHVybiByZXF1ZXN0UHJvbWlzZTtcbn1cblxuLy8gSGVscGVyIHRvIGRldGVybWluZSBpZiBhbiBlcnJvciBzaG91bGQgdHJpZ2dlciBhIHJldHJ5XG5mdW5jdGlvbiBzaG91bGRSZXRyeShlcnJvcjogYW55KTogYm9vbGVhbiB7XG4gICAgaWYgKCFlcnJvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gUmV0cnkgb24gbmV0d29yayBlcnJvcnMgb3IgY29ubmVjdGlvbiBpc3N1ZXNcbiAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZT8udG9Mb3dlckNhc2UoKSB8fCAnJztcbiAgICByZXR1cm4gbWVzc2FnZS5pbmNsdWRlcygnbmV0d29yaycpIHx8XG4gICAgICAgIG1lc3NhZ2UuaW5jbHVkZXMoJ2Nvbm5lY3Rpb24nKSB8fFxuICAgICAgICBtZXNzYWdlLmluY2x1ZGVzKCd0aW1lb3V0JykgfHxcbiAgICAgICAgbWVzc2FnZS5pbmNsdWRlcygnZXJyX2Nvbm5lY3Rpb25fY2xvc2VkJykgfHxcbiAgICAgICAgbWVzc2FnZS5pbmNsdWRlcygnZXJyX2ZhaWxlZCcpO1xufVxuXG4vLyBDYWNoZSBpbnZhbGlkYXRpb24gaGVscGVyXG5mdW5jdGlvbiBpbnZhbGlkYXRlQ2FjaGUocGF0dGVybjogc3RyaW5nKSB7XG4gICAgY29uc3Qga2V5c1RvRGVsZXRlOiBzdHJpbmdbXSA9IFtdO1xuICAgIHJlcXVlc3RDYWNoZS5mb3JFYWNoKChfLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGtleS5pbmNsdWRlcyhwYXR0ZXJuKSkge1xuICAgICAgICAgICAga2V5c1RvRGVsZXRlLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGtleXNUb0RlbGV0ZS5mb3JFYWNoKGtleSA9PiByZXF1ZXN0Q2FjaGUuZGVsZXRlKGtleSkpO1xufVxuXG4vLyBDbGVhciBhbGwgY2FjaGUgKHVzZWZ1bCBmb3IgbG9nb3V0IG9yIG1ham9yIHN0YXRlIGNoYW5nZXMpXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJTYXZlQ2FjaGUoKSB7XG4gICAgcmVxdWVzdENhY2hlLmNsZWFyKCk7XG4gICAgcGVuZGluZ1JlcXVlc3RzLmNsZWFyKCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2F2ZVJlc3VsdCB7XG4gICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICBlcnJvcj86IHN0cmluZztcbiAgICBzYXZlQ291bnQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2F2ZURhdGEge1xuICAgIHByb2R1Y3RJZDogc3RyaW5nO1xuICAgIGlzU2F2ZWQ6IGJvb2xlYW47XG4gICAgc2F2ZUNvdW50OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmF0Y2hTYXZlUmVzdWx0IHtcbiAgICBzdWNjZXNzOiBib29sZWFuO1xuICAgIGVycm9yPzogc3RyaW5nO1xuICAgIHJlc3VsdHM/OiBBcnJheTx7XG4gICAgICAgIHByb2R1Y3RJZDogc3RyaW5nO1xuICAgICAgICBpc1NhdmVkOiBib29sZWFuO1xuICAgICAgICBzYXZlQ291bnQ6IG51bWJlcjtcbiAgICB9Pjtcbn1cblxuLy8gRW5oYW5jZWQgY2xpZW50LXNpZGUgc2F2ZSBvcGVyYXRpb25zIHdpdGggYmV0dGVyIGVycm9yIGhhbmRsaW5nIGFuZCBwZXJmb3JtYW5jZVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZVByb2R1Y3QocHJvZHVjdElkOiBzdHJpbmcpOiBQcm9taXNlPFNhdmVSZXN1bHQ+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdVc2VyIG5vdCBhdXRoZW50aWNhdGVkJyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCdzYXZlcycpXG4gICAgICAgICAgICAuaW5zZXJ0KHsgdXNlcl9pZDogdXNlci5pZCwgcHJvZHVjdF9pZDogcHJvZHVjdElkIH0pO1xuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSGFuZGxlIHVuaXF1ZSBjb25zdHJhaW50IHZpb2xhdGlvbiBncmFjZWZ1bGx5XG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJzIzNTA1Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHNhdmVDb3VudDogMCB9OyAvLyBBbHJlYWR5IHNhdmVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEludmFsaWRhdGUgY2FjaGUgZm9yIHRoaXMgcHJvZHVjdFxuICAgICAgICBpbnZhbGlkYXRlQ2FjaGUocHJvZHVjdElkKTtcblxuICAgICAgICAvLyBHZXQgdXBkYXRlZCBzYXZlIGNvdW50XG4gICAgICAgIGNvbnN0IHsgZGF0YTogY291bnREYXRhLCBlcnJvcjogY291bnRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5ycGMoJ2dldF9wcm9kdWN0X3NhdmVfY291bnQnLCB7IHByb2R1Y3RfdXVpZDogcHJvZHVjdElkIH0pO1xuXG4gICAgICAgIGlmIChjb3VudEVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHNhdmUgY291bnQ6JywgY291bnRFcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIHNhdmVDb3VudDogY291bnREYXRhIHx8IDBcbiAgICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgcHJvZHVjdDonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnRmFpbGVkIHRvIHNhdmUgcHJvZHVjdCdcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1bnNhdmVQcm9kdWN0KHByb2R1Y3RJZDogc3RyaW5nKTogUHJvbWlzZTxTYXZlUmVzdWx0PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gICAgICAgIGlmICghdXNlcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnVXNlciBub3QgYXV0aGVudGljYXRlZCcgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgnc2F2ZXMnKVxuICAgICAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgICAgICAuZXEoJ3Byb2R1Y3RfaWQnLCBwcm9kdWN0SWQpXG4gICAgICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKTtcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW52YWxpZGF0ZSBjYWNoZSBmb3IgdGhpcyBwcm9kdWN0XG4gICAgICAgIGludmFsaWRhdGVDYWNoZShwcm9kdWN0SWQpO1xuXG4gICAgICAgIC8vIEdldCB1cGRhdGVkIHNhdmUgY291bnRcbiAgICAgICAgY29uc3QgeyBkYXRhOiBjb3VudERhdGEsIGVycm9yOiBjb3VudEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLnJwYygnZ2V0X3Byb2R1Y3Rfc2F2ZV9jb3VudCcsIHsgcHJvZHVjdF91dWlkOiBwcm9kdWN0SWQgfSk7XG5cbiAgICAgICAgaWYgKGNvdW50RXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgc2F2ZSBjb3VudDonLCBjb3VudEVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgc2F2ZUNvdW50OiBjb3VudERhdGEgfHwgMFxuICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVuc2F2aW5nIHByb2R1Y3Q6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byB1bnNhdmUgcHJvZHVjdCdcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VyU2F2ZWRQcm9kdWN0cygpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgcHJvZHVjdElkcz86IHN0cmluZ1tdOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gICAgICAgIGlmICghdXNlcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnVXNlciBub3QgYXV0aGVudGljYXRlZCcgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgnc2F2ZXMnKVxuICAgICAgICAgICAgLnNlbGVjdCgncHJvZHVjdF9pZCcpXG4gICAgICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuICAgICAgICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9kdWN0SWRzID0gZGF0YT8ubWFwKChpdGVtOiB7IHByb2R1Y3RfaWQ6IHN0cmluZyB9KSA9PiBpdGVtLnByb2R1Y3RfaWQpIHx8IFtdO1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBwcm9kdWN0SWRzIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBzYXZlZCBwcm9kdWN0czonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnRmFpbGVkIHRvIGdldCBzYXZlZCBwcm9kdWN0cydcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcm9kdWN0U2F2ZUNvdW50KHByb2R1Y3RJZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGNvdW50PzogbnVtYmVyOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBgc2F2ZV9jb3VudF8ke3Byb2R1Y3RJZH1gO1xuXG4gICAgcmV0dXJuIHRocm90dGxlZFJlcXVlc3QoY2FjaGVLZXksIGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLnJwYygnZ2V0X3Byb2R1Y3Rfc2F2ZV9jb3VudCcsIHsgcHJvZHVjdF91dWlkOiBwcm9kdWN0SWQgfSk7XG5cbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBjb3VudDogZGF0YSB8fCAwIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHNhdmUgY291bnQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byBnZXQgc2F2ZSBjb3VudCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzUHJvZHVjdFNhdmVkKHByb2R1Y3RJZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGlzU2F2ZWQ/OiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCk7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ1VzZXIgbm90IGF1dGhlbnRpY2F0ZWQnIH07XG4gICAgfVxuXG4gICAgY29uc3QgY2FjaGVLZXkgPSBgaXNfc2F2ZWRfJHtwcm9kdWN0SWR9XyR7dXNlci5pZH1gO1xuXG4gICAgcmV0dXJuIHRocm90dGxlZFJlcXVlc3QoY2FjaGVLZXksIGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAgICAgLnJwYygnaXNfcHJvZHVjdF9zYXZlZF9ieV91c2VyJywge1xuICAgICAgICAgICAgICAgICAgICBwcm9kdWN0X3V1aWQ6IHByb2R1Y3RJZCxcbiAgICAgICAgICAgICAgICAgICAgdXNlcl91dWlkOiB1c2VyLmlkXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBpc1NhdmVkOiBkYXRhIHx8IGZhbHNlIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBpZiBwcm9kdWN0IGlzIHNhdmVkOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdGYWlsZWQgdG8gY2hlY2sgc2F2ZSBzdGF0dXMnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8vIE5FVzogQmF0Y2ggb3BlcmF0aW9ucyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBiYXRjaEdldFByb2R1Y3RzU2F2ZURhdGEocHJvZHVjdElkczogc3RyaW5nW10pOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgZGF0YT86IFNhdmVEYXRhW107IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdVc2VyIG5vdCBhdXRoZW50aWNhdGVkJyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5ycGMoJ2dldF9wcm9kdWN0c19zYXZlX2RhdGEnIGFzIGFueSwge1xuICAgICAgICAgICAgICAgIHByb2R1Y3RfdXVpZHM6IHByb2R1Y3RJZHMsXG4gICAgICAgICAgICAgICAgdXNlcl91dWlkOiB1c2VyLmlkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2F2ZURhdGE6IFNhdmVEYXRhW10gPSAoZGF0YSBhcyBhbnlbXSk/Lm1hcCgoaXRlbTogYW55KSA9PiAoe1xuICAgICAgICAgICAgcHJvZHVjdElkOiBpdGVtLnByb2R1Y3RfaWQsXG4gICAgICAgICAgICBpc1NhdmVkOiBpdGVtLmlzX3NhdmVkLFxuICAgICAgICAgICAgc2F2ZUNvdW50OiBpdGVtLnNhdmVfY291bnRcbiAgICAgICAgfSkpIHx8IFtdO1xuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHNhdmVEYXRhIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBiYXRjaCBzYXZlIGRhdGE6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byBnZXQgYmF0Y2ggc2F2ZSBkYXRhJ1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJhdGNoVG9nZ2xlU2F2ZXMoXG4gICAgcHJvZHVjdElkczogc3RyaW5nW10sXG4gICAgYWN0aW9uOiAnc2F2ZScgfCAndW5zYXZlJ1xuKTogUHJvbWlzZTxCYXRjaFNhdmVSZXN1bHQ+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdVc2VyIG5vdCBhdXRoZW50aWNhdGVkJyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5ycGMoJ2JhdGNoX3RvZ2dsZV9zYXZlcycgYXMgYW55LCB7XG4gICAgICAgICAgICAgICAgcHJvZHVjdF91dWlkczogcHJvZHVjdElkcyxcbiAgICAgICAgICAgICAgICB1c2VyX3V1aWQ6IHVzZXIuaWQsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHRzID0gKGRhdGEgYXMgYW55W10pPy5tYXAoKGl0ZW06IGFueSkgPT4gKHtcbiAgICAgICAgICAgIHByb2R1Y3RJZDogaXRlbS5wcm9kdWN0X2lkLFxuICAgICAgICAgICAgaXNTYXZlZDogYWN0aW9uID09PSAnc2F2ZScsXG4gICAgICAgICAgICBzYXZlQ291bnQ6IGl0ZW0ubmV3X3NhdmVfY291bnRcbiAgICAgICAgfSkpIHx8IFtdO1xuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHJlc3VsdHMgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBiYXRjaCB0b2dnbGluZyBzYXZlczonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnRmFpbGVkIHRvIGJhdGNoIHRvZ2dsZSBzYXZlcydcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8vIE5FVzogR2V0IHNhdmVkIHByb2R1Y3RzIHdpdGggbWV0YWRhdGEgZm9yIGEgZGVkaWNhdGVkIHNhdmVkIHBhZ2VcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VyU2F2ZWRQcm9kdWN0c1dpdGhNZXRhZGF0YSgpOiBQcm9taXNlPHtcbiAgICBzdWNjZXNzOiBib29sZWFuO1xuICAgIHByb2R1Y3RzPzogQXJyYXk8e1xuICAgICAgICBwcm9kdWN0SWQ6IHN0cmluZztcbiAgICAgICAgc2F2ZWRBdDogc3RyaW5nO1xuICAgICAgICBwcm9kdWN0VGl0bGU6IHN0cmluZztcbiAgICAgICAgcHJvZHVjdFByaWNlUGVuY2U6IG51bWJlcjtcbiAgICAgICAgcHJvZHVjdEltYWdlczogc3RyaW5nW107XG4gICAgfT47XG4gICAgZXJyb3I/OiBzdHJpbmdcbn0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdVc2VyIG5vdCBhdXRoZW50aWNhdGVkJyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5ycGMoJ2dldF91c2VyX3NhdmVkX3Byb2R1Y3RzX3dpdGhfbWV0YWRhdGEnIGFzIGFueSwge1xuICAgICAgICAgICAgICAgIHVzZXJfdXVpZDogdXNlci5pZFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb2R1Y3RzID0gKGRhdGEgYXMgYW55W10pPy5tYXAoKGl0ZW06IGFueSkgPT4gKHtcbiAgICAgICAgICAgIHByb2R1Y3RJZDogaXRlbS5wcm9kdWN0X2lkLFxuICAgICAgICAgICAgc2F2ZWRBdDogaXRlbS5zYXZlZF9hdCxcbiAgICAgICAgICAgIHByb2R1Y3RUaXRsZTogaXRlbS5wcm9kdWN0X3RpdGxlLFxuICAgICAgICAgICAgcHJvZHVjdFByaWNlUGVuY2U6IGl0ZW0ucHJvZHVjdF9wcmljZV9wZW5jZSxcbiAgICAgICAgICAgIHByb2R1Y3RJbWFnZXM6IGl0ZW0ucHJvZHVjdF9pbWFnZXMgfHwgW11cbiAgICAgICAgfSkpIHx8IFtdO1xuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHByb2R1Y3RzIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBzYXZlZCBwcm9kdWN0cyB3aXRoIG1ldGFkYXRhOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdGYWlsZWQgdG8gZ2V0IHNhdmVkIHByb2R1Y3RzIHdpdGggbWV0YWRhdGEnXG4gICAgICAgIH07XG4gICAgfVxufVxuXG4iXSwibmFtZXMiOlsic3VwYWJhc2UiLCJyZXF1ZXN0Q2FjaGUiLCJNYXAiLCJwZW5kaW5nUmVxdWVzdHMiLCJSRVFVRVNUX0NBQ0hFX0RVUkFUSU9OIiwiUkVRVUVTVF9USFJPVFRMRV9ERUxBWSIsInRocm90dGxlZFJlcXVlc3QiLCJrZXkiLCJyZXF1ZXN0Rm4iLCJ1c2VDYWNoZSIsIm1heFJldHJpZXMiLCJjYWNoZWQiLCJnZXQiLCJEYXRlIiwibm93IiwidGltZXN0YW1wIiwiZGF0YSIsImhhcyIsInJlcXVlc3RQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJhdHRlbXB0cyIsImF0dGVtcHRSZXF1ZXN0IiwicmVzdWx0Iiwic2V0IiwiZXJyb3IiLCJzaG91bGRSZXRyeSIsImRlbGF5IiwiTWF0aCIsInBvdyIsInNldFRpbWVvdXQiLCJkZWxldGUiLCJtZXNzYWdlIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsImludmFsaWRhdGVDYWNoZSIsInBhdHRlcm4iLCJrZXlzVG9EZWxldGUiLCJmb3JFYWNoIiwiXyIsInB1c2giLCJjbGVhclNhdmVDYWNoZSIsImNsZWFyIiwic2F2ZVByb2R1Y3QiLCJwcm9kdWN0SWQiLCJ1c2VyIiwiYXV0aCIsImdldFVzZXIiLCJzdWNjZXNzIiwiZnJvbSIsImluc2VydCIsInVzZXJfaWQiLCJpZCIsInByb2R1Y3RfaWQiLCJjb2RlIiwic2F2ZUNvdW50IiwiY291bnREYXRhIiwiY291bnRFcnJvciIsInJwYyIsInByb2R1Y3RfdXVpZCIsImNvbnNvbGUiLCJ1bnNhdmVQcm9kdWN0IiwiZXEiLCJnZXRVc2VyU2F2ZWRQcm9kdWN0cyIsInNlbGVjdCIsIm9yZGVyIiwiYXNjZW5kaW5nIiwicHJvZHVjdElkcyIsIm1hcCIsIml0ZW0iLCJnZXRQcm9kdWN0U2F2ZUNvdW50IiwiY2FjaGVLZXkiLCJjb3VudCIsImlzUHJvZHVjdFNhdmVkIiwidXNlcl91dWlkIiwiaXNTYXZlZCIsImJhdGNoR2V0UHJvZHVjdHNTYXZlRGF0YSIsInByb2R1Y3RfdXVpZHMiLCJzYXZlRGF0YSIsImlzX3NhdmVkIiwic2F2ZV9jb3VudCIsImJhdGNoVG9nZ2xlU2F2ZXMiLCJhY3Rpb24iLCJyZXN1bHRzIiwibmV3X3NhdmVfY291bnQiLCJnZXRVc2VyU2F2ZWRQcm9kdWN0c1dpdGhNZXRhZGF0YSIsInByb2R1Y3RzIiwic2F2ZWRBdCIsInNhdmVkX2F0IiwicHJvZHVjdFRpdGxlIiwicHJvZHVjdF90aXRsZSIsInByb2R1Y3RQcmljZVBlbmNlIiwicHJvZHVjdF9wcmljZV9wZW5jZSIsInByb2R1Y3RJbWFnZXMiLCJwcm9kdWN0X2ltYWdlcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/savesEnhanced.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/stores/saveStore.ts":
/*!*********************************!*\
  !*** ./src/stores/saveStore.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSaveStore: () => (/* binding */ useSaveStore)\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n\n\nconst useSaveStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_1__.devtools)((set, get)=>({\n        // Initial state\n        savedProducts: new Set(),\n        saveCounts: {},\n        error: null,\n        // Actions\n        setSavedProducts: (productIds)=>{\n            set({\n                savedProducts: new Set(productIds)\n            });\n        },\n        addSavedProduct: (productId)=>{\n            const { savedProducts, saveCounts } = get();\n            const newSavedProducts = new Set(savedProducts);\n            newSavedProducts.add(productId);\n            set({\n                savedProducts: newSavedProducts,\n                saveCounts: {\n                    ...saveCounts,\n                    [productId]: (saveCounts[productId] || 0) + 1\n                }\n            });\n        },\n        removeSavedProduct: (productId)=>{\n            const { savedProducts, saveCounts } = get();\n            const newSavedProducts = new Set(savedProducts);\n            newSavedProducts.delete(productId);\n            set({\n                savedProducts: newSavedProducts,\n                saveCounts: {\n                    ...saveCounts,\n                    [productId]: Math.max((saveCounts[productId] || 1) - 1, 0)\n                }\n            });\n        },\n        setSaveCount: (productId, count)=>{\n            set((state)=>({\n                    saveCounts: {\n                        ...state.saveCounts,\n                        [productId]: count\n                    }\n                }));\n        },\n        // Batch update multiple products' save data\n        batchUpdateSaveData: (data)=>{\n            const { savedProducts, saveCounts } = get();\n            const newSavedProducts = new Set(savedProducts);\n            const newSaveCounts = {\n                ...saveCounts\n            };\n            data.forEach((param)=>{\n                let { productId, isSaved, saveCount } = param;\n                if (isSaved) {\n                    newSavedProducts.add(productId);\n                } else {\n                    newSavedProducts.delete(productId);\n                }\n                newSaveCounts[productId] = saveCount;\n            });\n            set({\n                savedProducts: newSavedProducts,\n                saveCounts: newSaveCounts\n            });\n        },\n        setError: (error)=>{\n            set({\n                error\n            });\n        },\n        isProductSaved: (productId)=>{\n            return get().savedProducts.has(productId);\n        },\n        getSaveCount: (productId)=>{\n            return get().saveCounts[productId] || 0;\n        },\n        clearError: ()=>{\n            set({\n                error: null\n            });\n        },\n        reset: ()=>{\n            set({\n                savedProducts: new Set(),\n                saveCounts: {},\n                error: null\n            });\n        }\n    }), {\n    name: 'save-store-enhanced'\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZXMvc2F2ZVN0b3JlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpQztBQUNhO0FBMkJ2QyxNQUFNRSxlQUFlRiwrQ0FBTUEsR0FDOUJDLDREQUFRQSxDQUNKLENBQUNFLEtBQUtDLE1BQVM7UUFDWCxnQkFBZ0I7UUFDaEJDLGVBQWUsSUFBSUM7UUFDbkJDLFlBQVksQ0FBQztRQUNiQyxPQUFPO1FBRVAsVUFBVTtRQUNWQyxrQkFBa0IsQ0FBQ0M7WUFDZlAsSUFBSTtnQkFBRUUsZUFBZSxJQUFJQyxJQUFJSTtZQUFZO1FBQzdDO1FBRUFDLGlCQUFpQixDQUFDQztZQUNkLE1BQU0sRUFBRVAsYUFBYSxFQUFFRSxVQUFVLEVBQUUsR0FBR0g7WUFDdEMsTUFBTVMsbUJBQW1CLElBQUlQLElBQUlEO1lBQ2pDUSxpQkFBaUJDLEdBQUcsQ0FBQ0Y7WUFFckJULElBQUk7Z0JBQ0FFLGVBQWVRO2dCQUNmTixZQUFZO29CQUNSLEdBQUdBLFVBQVU7b0JBQ2IsQ0FBQ0ssVUFBVSxFQUFFLENBQUNMLFVBQVUsQ0FBQ0ssVUFBVSxJQUFJLEtBQUs7Z0JBQ2hEO1lBQ0o7UUFDSjtRQUVBRyxvQkFBb0IsQ0FBQ0g7WUFDakIsTUFBTSxFQUFFUCxhQUFhLEVBQUVFLFVBQVUsRUFBRSxHQUFHSDtZQUN0QyxNQUFNUyxtQkFBbUIsSUFBSVAsSUFBSUQ7WUFDakNRLGlCQUFpQkcsTUFBTSxDQUFDSjtZQUV4QlQsSUFBSTtnQkFDQUUsZUFBZVE7Z0JBQ2ZOLFlBQVk7b0JBQ1IsR0FBR0EsVUFBVTtvQkFDYixDQUFDSyxVQUFVLEVBQUVLLEtBQUtDLEdBQUcsQ0FBQyxDQUFDWCxVQUFVLENBQUNLLFVBQVUsSUFBSSxLQUFLLEdBQUc7Z0JBQzVEO1lBQ0o7UUFDSjtRQUVBTyxjQUFjLENBQUNQLFdBQW1CUTtZQUM5QmpCLElBQUksQ0FBQ2tCLFFBQVc7b0JBQ1pkLFlBQVk7d0JBQ1IsR0FBR2MsTUFBTWQsVUFBVTt3QkFDbkIsQ0FBQ0ssVUFBVSxFQUFFUTtvQkFDakI7Z0JBQ0o7UUFDSjtRQUVBLDRDQUE0QztRQUM1Q0UscUJBQXFCLENBQUNDO1lBQ2xCLE1BQU0sRUFBRWxCLGFBQWEsRUFBRUUsVUFBVSxFQUFFLEdBQUdIO1lBQ3RDLE1BQU1TLG1CQUFtQixJQUFJUCxJQUFJRDtZQUNqQyxNQUFNbUIsZ0JBQWdCO2dCQUFFLEdBQUdqQixVQUFVO1lBQUM7WUFFdENnQixLQUFLRSxPQUFPLENBQUM7b0JBQUMsRUFBRWIsU0FBUyxFQUFFYyxPQUFPLEVBQUVDLFNBQVMsRUFBRTtnQkFDM0MsSUFBSUQsU0FBUztvQkFDVGIsaUJBQWlCQyxHQUFHLENBQUNGO2dCQUN6QixPQUFPO29CQUNIQyxpQkFBaUJHLE1BQU0sQ0FBQ0o7Z0JBQzVCO2dCQUNBWSxhQUFhLENBQUNaLFVBQVUsR0FBR2U7WUFDL0I7WUFFQXhCLElBQUk7Z0JBQ0FFLGVBQWVRO2dCQUNmTixZQUFZaUI7WUFDaEI7UUFDSjtRQUVBSSxVQUFVLENBQUNwQjtZQUNQTCxJQUFJO2dCQUFFSztZQUFNO1FBQ2hCO1FBRUFxQixnQkFBZ0IsQ0FBQ2pCO1lBQ2IsT0FBT1IsTUFBTUMsYUFBYSxDQUFDeUIsR0FBRyxDQUFDbEI7UUFDbkM7UUFFQW1CLGNBQWMsQ0FBQ25CO1lBQ1gsT0FBT1IsTUFBTUcsVUFBVSxDQUFDSyxVQUFVLElBQUk7UUFDMUM7UUFFQW9CLFlBQVk7WUFDUjdCLElBQUk7Z0JBQUVLLE9BQU87WUFBSztRQUN0QjtRQUVBeUIsT0FBTztZQUNIOUIsSUFBSTtnQkFDQUUsZUFBZSxJQUFJQztnQkFDbkJDLFlBQVksQ0FBQztnQkFDYkMsT0FBTztZQUNYO1FBQ0o7SUFDSixJQUNBO0lBQ0kwQixNQUFNO0FBQ1YsSUFFTiIsInNvdXJjZXMiOlsiL1VzZXJzL2lmZWRheW9hZ2Jvb2xhL0Rlc2t0b3AvbXlQcm9qZWN0cy9ldGhuaXFyb290ei1uZXh0anMvc3JjL3N0b3Jlcy9zYXZlU3RvcmUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCc7XG5pbXBvcnQgeyBkZXZ0b29scyB9IGZyb20gJ3p1c3RhbmQvbWlkZGxld2FyZSc7XG5cbmludGVyZmFjZSBTYXZlRGF0YSB7XG4gICAgcHJvZHVjdElkOiBzdHJpbmc7XG4gICAgaXNTYXZlZDogYm9vbGVhbjtcbiAgICBzYXZlQ291bnQ6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFNhdmVTdGF0ZSB7XG4gICAgLy8gU3RhdGVcbiAgICBzYXZlZFByb2R1Y3RzOiBTZXQ8c3RyaW5nPjtcbiAgICBzYXZlQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xuICAgIGVycm9yOiBzdHJpbmcgfCBudWxsO1xuXG4gICAgLy8gQWN0aW9uc1xuICAgIHNldFNhdmVkUHJvZHVjdHM6IChwcm9kdWN0SWRzOiBzdHJpbmdbXSkgPT4gdm9pZDtcbiAgICBhZGRTYXZlZFByb2R1Y3Q6IChwcm9kdWN0SWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgICByZW1vdmVTYXZlZFByb2R1Y3Q6IChwcm9kdWN0SWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgICBzZXRTYXZlQ291bnQ6IChwcm9kdWN0SWQ6IHN0cmluZywgY291bnQ6IG51bWJlcikgPT4gdm9pZDtcbiAgICBiYXRjaFVwZGF0ZVNhdmVEYXRhOiAoZGF0YTogU2F2ZURhdGFbXSkgPT4gdm9pZDtcbiAgICBzZXRFcnJvcjogKGVycm9yOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xuICAgIGlzUHJvZHVjdFNhdmVkOiAocHJvZHVjdElkOiBzdHJpbmcpID0+IGJvb2xlYW47XG4gICAgZ2V0U2F2ZUNvdW50OiAocHJvZHVjdElkOiBzdHJpbmcpID0+IG51bWJlcjtcbiAgICBjbGVhckVycm9yOiAoKSA9PiB2b2lkO1xuICAgIHJlc2V0OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgdXNlU2F2ZVN0b3JlID0gY3JlYXRlPFNhdmVTdGF0ZT4oKShcbiAgICBkZXZ0b29scyhcbiAgICAgICAgKHNldCwgZ2V0KSA9PiAoe1xuICAgICAgICAgICAgLy8gSW5pdGlhbCBzdGF0ZVxuICAgICAgICAgICAgc2F2ZWRQcm9kdWN0czogbmV3IFNldCgpLFxuICAgICAgICAgICAgc2F2ZUNvdW50czoge30sXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcblxuICAgICAgICAgICAgLy8gQWN0aW9uc1xuICAgICAgICAgICAgc2V0U2F2ZWRQcm9kdWN0czogKHByb2R1Y3RJZHM6IHN0cmluZ1tdKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0KHsgc2F2ZWRQcm9kdWN0czogbmV3IFNldChwcm9kdWN0SWRzKSB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGFkZFNhdmVkUHJvZHVjdDogKHByb2R1Y3RJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzYXZlZFByb2R1Y3RzLCBzYXZlQ291bnRzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTYXZlZFByb2R1Y3RzID0gbmV3IFNldChzYXZlZFByb2R1Y3RzKTtcbiAgICAgICAgICAgICAgICBuZXdTYXZlZFByb2R1Y3RzLmFkZChwcm9kdWN0SWQpO1xuXG4gICAgICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgc2F2ZWRQcm9kdWN0czogbmV3U2F2ZWRQcm9kdWN0cyxcbiAgICAgICAgICAgICAgICAgICAgc2F2ZUNvdW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc2F2ZUNvdW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtwcm9kdWN0SWRdOiAoc2F2ZUNvdW50c1twcm9kdWN0SWRdIHx8IDApICsgMSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlbW92ZVNhdmVkUHJvZHVjdDogKHByb2R1Y3RJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzYXZlZFByb2R1Y3RzLCBzYXZlQ291bnRzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTYXZlZFByb2R1Y3RzID0gbmV3IFNldChzYXZlZFByb2R1Y3RzKTtcbiAgICAgICAgICAgICAgICBuZXdTYXZlZFByb2R1Y3RzLmRlbGV0ZShwcm9kdWN0SWQpO1xuXG4gICAgICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgc2F2ZWRQcm9kdWN0czogbmV3U2F2ZWRQcm9kdWN0cyxcbiAgICAgICAgICAgICAgICAgICAgc2F2ZUNvdW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc2F2ZUNvdW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtwcm9kdWN0SWRdOiBNYXRoLm1heCgoc2F2ZUNvdW50c1twcm9kdWN0SWRdIHx8IDEpIC0gMSwgMCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRTYXZlQ291bnQ6IChwcm9kdWN0SWQ6IHN0cmluZywgY291bnQ6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIHNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIHNhdmVDb3VudHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YXRlLnNhdmVDb3VudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBbcHJvZHVjdElkXTogY291bnQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gQmF0Y2ggdXBkYXRlIG11bHRpcGxlIHByb2R1Y3RzJyBzYXZlIGRhdGFcbiAgICAgICAgICAgIGJhdGNoVXBkYXRlU2F2ZURhdGE6IChkYXRhOiBTYXZlRGF0YVtdKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzYXZlZFByb2R1Y3RzLCBzYXZlQ291bnRzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTYXZlZFByb2R1Y3RzID0gbmV3IFNldChzYXZlZFByb2R1Y3RzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTYXZlQ291bnRzID0geyAuLi5zYXZlQ291bnRzIH07XG5cbiAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goKHsgcHJvZHVjdElkLCBpc1NhdmVkLCBzYXZlQ291bnQgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTYXZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2F2ZWRQcm9kdWN0cy5hZGQocHJvZHVjdElkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NhdmVkUHJvZHVjdHMuZGVsZXRlKHByb2R1Y3RJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3U2F2ZUNvdW50c1twcm9kdWN0SWRdID0gc2F2ZUNvdW50O1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgc2F2ZWRQcm9kdWN0czogbmV3U2F2ZWRQcm9kdWN0cyxcbiAgICAgICAgICAgICAgICAgICAgc2F2ZUNvdW50czogbmV3U2F2ZUNvdW50cyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldEVycm9yOiAoZXJyb3I6IHN0cmluZyB8IG51bGwpID0+IHtcbiAgICAgICAgICAgICAgICBzZXQoeyBlcnJvciB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGlzUHJvZHVjdFNhdmVkOiAocHJvZHVjdElkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0KCkuc2F2ZWRQcm9kdWN0cy5oYXMocHJvZHVjdElkKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldFNhdmVDb3VudDogKHByb2R1Y3RJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldCgpLnNhdmVDb3VudHNbcHJvZHVjdElkXSB8fCAwO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2xlYXJFcnJvcjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldCh7IGVycm9yOiBudWxsIH0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgICAgICBzYXZlZFByb2R1Y3RzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgICAgIHNhdmVDb3VudHM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnc2F2ZS1zdG9yZS1lbmhhbmNlZCcsXG4gICAgICAgIH1cbiAgICApXG4pO1xuXG4iXSwibmFtZXMiOlsiY3JlYXRlIiwiZGV2dG9vbHMiLCJ1c2VTYXZlU3RvcmUiLCJzZXQiLCJnZXQiLCJzYXZlZFByb2R1Y3RzIiwiU2V0Iiwic2F2ZUNvdW50cyIsImVycm9yIiwic2V0U2F2ZWRQcm9kdWN0cyIsInByb2R1Y3RJZHMiLCJhZGRTYXZlZFByb2R1Y3QiLCJwcm9kdWN0SWQiLCJuZXdTYXZlZFByb2R1Y3RzIiwiYWRkIiwicmVtb3ZlU2F2ZWRQcm9kdWN0IiwiZGVsZXRlIiwiTWF0aCIsIm1heCIsInNldFNhdmVDb3VudCIsImNvdW50Iiwic3RhdGUiLCJiYXRjaFVwZGF0ZVNhdmVEYXRhIiwiZGF0YSIsIm5ld1NhdmVDb3VudHMiLCJmb3JFYWNoIiwiaXNTYXZlZCIsInNhdmVDb3VudCIsInNldEVycm9yIiwiaXNQcm9kdWN0U2F2ZWQiLCJoYXMiLCJnZXRTYXZlQ291bnQiLCJjbGVhckVycm9yIiwicmVzZXQiLCJuYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/stores/saveStore.ts\n"));

/***/ })

});