"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/search/page",{

/***/ "(app-pages-browser)/./src/hooks/useSearch.ts":
/*!********************************!*\
  !*** ./src/hooks/useSearch.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSearch: () => (/* binding */ useSearch)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _lib_search__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/search */ \"(app-pages-browser)/./src/lib/search.ts\");\n/* harmony import */ var _useGlobalLoading__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useGlobalLoading */ \"(app-pages-browser)/./src/hooks/useGlobalLoading.ts\");\n/* __next_internal_client_entry_do_not_use__ useSearch auto */ \n\n\n\nfunction useSearch() {\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_1__.useRouter)();\n    const searchParams = (0,next_navigation__WEBPACK_IMPORTED_MODULE_1__.useSearchParams)();\n    const { showLoading, hideLoading } = (0,_useGlobalLoading__WEBPACK_IMPORTED_MODULE_3__.useGlobalLoading)();\n    const [query, setQuery] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(searchParams.get('q') || '');\n    const [filters, setFilters] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        query: searchParams.get('q') || undefined,\n        category: searchParams.get('category') || undefined,\n        status: searchParams.get('status') || undefined,\n        city: searchParams.get('city') || undefined\n    });\n    const [results, setResults] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [suggestions, setSuggestions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [showSuggestions, setShowSuggestions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Debounced search function\n    const debouncedSearch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(debounce({\n        \"useSearch.useCallback[debouncedSearch]\": async (searchFilters)=>{\n            setIsLoading(true);\n            setError(null);\n            try {\n                const response = await (0,_lib_search__WEBPACK_IMPORTED_MODULE_2__.searchProducts)(searchFilters);\n                if (response.success && response.products) {\n                    setResults(response.products);\n                } else {\n                    setError(response.error || 'Search failed');\n                    setResults([]);\n                }\n            } catch (err) {\n                setError('Search failed');\n                setResults([]);\n            } finally{\n                setIsLoading(false);\n            }\n        }\n    }[\"useSearch.useCallback[debouncedSearch]\"], 300), []);\n    // Update URL with search parameters\n    const updateURL = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSearch.useCallback[updateURL]\": (newFilters)=>{\n            const params = new URLSearchParams();\n            if (newFilters.query) params.set('q', newFilters.query);\n            if (newFilters.category) params.set('category', newFilters.category);\n            if (newFilters.status) params.set('status', newFilters.status);\n            if (newFilters.city) params.set('city', newFilters.city);\n            const newURL = params.toString() ? \"/search?\".concat(params.toString()) : '/search';\n            router.push(newURL);\n        }\n    }[\"useSearch.useCallback[updateURL]\"], [\n        router\n    ]);\n    // Handle search input\n    const handleSearch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSearch.useCallback[handleSearch]\": (searchQuery)=>{\n            setQuery(searchQuery);\n            const newFilters = {\n                ...filters,\n                query: searchQuery\n            };\n            setFilters(newFilters);\n            updateURL(newFilters);\n            debouncedSearch(newFilters);\n        }\n    }[\"useSearch.useCallback[handleSearch]\"], [\n        filters,\n        updateURL,\n        debouncedSearch\n    ]);\n    // Handle filter changes\n    const handleFilterChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSearch.useCallback[handleFilterChange]\": (key, value)=>{\n            const newFilters = {\n                ...filters,\n                [key]: value\n            };\n            setFilters(newFilters);\n            updateURL(newFilters);\n            debouncedSearch(newFilters);\n        }\n    }[\"useSearch.useCallback[handleFilterChange]\"], [\n        filters,\n        updateURL,\n        debouncedSearch\n    ]);\n    // Clear all filters\n    const clearFilters = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSearch.useCallback[clearFilters]\": ()=>{\n            const newFilters = {\n                query: ''\n            };\n            setFilters(newFilters);\n            setQuery('');\n            updateURL(newFilters);\n            debouncedSearch(newFilters);\n        }\n    }[\"useSearch.useCallback[clearFilters]\"], [\n        updateURL,\n        debouncedSearch\n    ]);\n    // Get suggestions for current query\n    const updateSuggestions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSearch.useCallback[updateSuggestions]\": async (searchQuery)=>{\n            if (searchQuery.length >= 2) {\n                const newSuggestions = await (0,_lib_search__WEBPACK_IMPORTED_MODULE_2__.getSearchSuggestions)(searchQuery);\n                setSuggestions(newSuggestions);\n                setShowSuggestions(true);\n            } else {\n                setSuggestions([]);\n                setShowSuggestions(false);\n            }\n        }\n    }[\"useSearch.useCallback[updateSuggestions]\"], []);\n    // Debounced suggestion update\n    const debouncedSuggestions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(debounce(updateSuggestions, 200), [\n        updateSuggestions\n    ]);\n    // Handle input change with suggestions\n    const handleInputChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSearch.useCallback[handleInputChange]\": (value)=>{\n            setQuery(value);\n            debouncedSuggestions(value);\n        }\n    }[\"useSearch.useCallback[handleInputChange]\"], [\n        debouncedSuggestions\n    ]);\n    // Select suggestion\n    const selectSuggestion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSearch.useCallback[selectSuggestion]\": (suggestion)=>{\n            setQuery(suggestion);\n            setShowSuggestions(false);\n            handleSearch(suggestion);\n        }\n    }[\"useSearch.useCallback[selectSuggestion]\"], [\n        handleSearch\n    ]);\n    // Initial search on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSearch.useEffect\": ()=>{\n            if (filters.query || filters.category || filters.status || filters.city) {\n                debouncedSearch(filters);\n            }\n        }\n    }[\"useSearch.useEffect\"], []);\n    // Memoized filter counts\n    const activeFiltersCount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)({\n        \"useSearch.useMemo[activeFiltersCount]\": ()=>{\n            return Object.values(filters).filter({\n                \"useSearch.useMemo[activeFiltersCount]\": (value)=>value && value !== ''\n            }[\"useSearch.useMemo[activeFiltersCount]\"]).length;\n        }\n    }[\"useSearch.useMemo[activeFiltersCount]\"], [\n        filters\n    ]);\n    return {\n        // State\n        query,\n        filters,\n        results,\n        isLoading,\n        error,\n        suggestions,\n        showSuggestions,\n        activeFiltersCount,\n        // Actions\n        handleSearch,\n        handleInputChange,\n        handleFilterChange,\n        clearFilters,\n        selectSuggestion,\n        setShowSuggestions,\n        // Helpers\n        hasResults: results.length > 0,\n        hasFilters: activeFiltersCount > 0\n    };\n}\n// Simple debounce utility\nfunction debounce(func, wait) {\n    let timeout;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        clearTimeout(timeout);\n        timeout = setTimeout(()=>func(...args), wait);\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VTZWFyY2gudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OytEQUVrRTtBQUNMO0FBQ3NCO0FBQzdCO0FBRS9DLFNBQVNTO0lBQ1osTUFBTUMsU0FBU04sMERBQVNBO0lBQ3hCLE1BQU1PLGVBQWVOLGdFQUFlQTtJQUNwQyxNQUFNLEVBQUVPLFdBQVcsRUFBRUMsV0FBVyxFQUFFLEdBQUdMLG1FQUFnQkE7SUFFckQsTUFBTSxDQUFDTSxPQUFPQyxTQUFTLEdBQUdmLCtDQUFRQSxDQUFDVyxhQUFhSyxHQUFHLENBQUMsUUFBUTtJQUM1RCxNQUFNLENBQUNDLFNBQVNDLFdBQVcsR0FBR2xCLCtDQUFRQSxDQUFnQjtRQUNsRGMsT0FBT0gsYUFBYUssR0FBRyxDQUFDLFFBQVFHO1FBQ2hDQyxVQUFVVCxhQUFhSyxHQUFHLENBQUMsZUFBZUc7UUFDMUNFLFFBQVFWLGFBQWFLLEdBQUcsQ0FBQyxhQUFhRztRQUN0Q0csTUFBTVgsYUFBYUssR0FBRyxDQUFDLFdBQVdHO0lBQ3RDO0lBQ0EsTUFBTSxDQUFDSSxTQUFTQyxXQUFXLEdBQUd4QiwrQ0FBUUEsQ0FBUSxFQUFFO0lBQ2hELE1BQU0sQ0FBQ3lCLFdBQVdDLGFBQWEsR0FBRzFCLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQzJCLE9BQU9DLFNBQVMsR0FBRzVCLCtDQUFRQSxDQUFnQjtJQUNsRCxNQUFNLENBQUM2QixhQUFhQyxlQUFlLEdBQUc5QiwrQ0FBUUEsQ0FBVyxFQUFFO0lBQzNELE1BQU0sQ0FBQytCLGlCQUFpQkMsbUJBQW1CLEdBQUdoQywrQ0FBUUEsQ0FBQztJQUV2RCw0QkFBNEI7SUFDNUIsTUFBTWlDLGtCQUFrQi9CLGtEQUFXQSxDQUMvQmdDO2tEQUFTLE9BQU9DO1lBQ1pULGFBQWE7WUFDYkUsU0FBUztZQUVULElBQUk7Z0JBQ0EsTUFBTVEsV0FBVyxNQUFNOUIsMkRBQWNBLENBQUM2QjtnQkFFdEMsSUFBSUMsU0FBU0MsT0FBTyxJQUFJ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Q04sSUFBSWdCLFFBQVFILEtBQUssSUFBSUcsUUFBUUcsUUFBUSxJQUFJSCxRQUFRSSxNQUFNLElBQUlKLFFBQVFLLElBQUksRUFBRTtnQkFDckVXLGdCQUFnQmhCO1lBQ3BCO1FBQ0o7OEJBQUcsRUFBRTtJQUVMLHlCQUF5QjtJQUN6QixNQUFNNEMscUJBQXFCMUQsOENBQU9BO2lEQUFDO1lBQy9CLE9BQU8yRCxPQUFPQyxNQUFNLENBQUM5QyxTQUFTK0MsTUFBTTt5REFBQ1osQ0FBQUEsUUFBU0EsU0FBU0EsVUFBVTt3REFBSUcsTUFBTTtRQUMvRTtnREFBRztRQUFDdEM7S0FBUTtJQUVaLE9BQU87UUFDSCxRQUFRO1FBQ1JIO1FBQ0FHO1FBQ0FNO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0E4QjtRQUVBLFVBQVU7UUFDVmI7UUFDQVU7UUFDQVI7UUFDQUc7UUFDQU07UUFDQTNCO1FBRUEsVUFBVTtRQUNWaUMsWUFBWTFDLFFBQVFnQyxNQUFNLEdBQUc7UUFDN0JXLFlBQVlMLHFCQUFxQjtJQUNyQztBQUNKO0FBRUEsMEJBQTBCO0FBQzFCLFNBQVMzQixTQUNMaUMsSUFBTyxFQUNQQyxJQUFZO0lBRVosSUFBSUM7SUFDSixPQUFPO3lDQUFJQztZQUFBQTs7UUFDUEMsYUFBYUY7UUFDYkEsVUFBVUcsV0FBVyxJQUFNTCxRQUFRRyxPQUFPRjtJQUM5QztBQUNKIiwic291cmNlcyI6WyIvVXNlcnMvaWZlZGF5b2FnYm9vbGEvRGVza3RvcC9teVByb2plY3RzL2V0aG5pcXJvb3R6LW5leHRqcy9zcmMvaG9va3MvdXNlU2VhcmNoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VSb3V0ZXIsIHVzZVNlYXJjaFBhcmFtcyB9IGZyb20gJ25leHQvbmF2aWdhdGlvbic7XG5pbXBvcnQgeyBzZWFyY2hQcm9kdWN0cywgZ2V0U2VhcmNoU3VnZ2VzdGlvbnMsIFNlYXJjaEZpbHRlcnMgfSBmcm9tICdAL2xpYi9zZWFyY2gnO1xuaW1wb3J0IHsgdXNlR2xvYmFsTG9hZGluZyB9IGZyb20gJy4vdXNlR2xvYmFsTG9hZGluZyc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTZWFyY2goKSB7XG4gICAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gdXNlU2VhcmNoUGFyYW1zKCk7XG4gICAgY29uc3QgeyBzaG93TG9hZGluZywgaGlkZUxvYWRpbmcgfSA9IHVzZUdsb2JhbExvYWRpbmcoKTtcblxuICAgIGNvbnN0IFtxdWVyeSwgc2V0UXVlcnldID0gdXNlU3RhdGUoc2VhcmNoUGFyYW1zLmdldCgncScpIHx8ICcnKTtcbiAgICBjb25zdCBbZmlsdGVycywgc2V0RmlsdGVyc10gPSB1c2VTdGF0ZTxTZWFyY2hGaWx0ZXJzPih7XG4gICAgICAgIHF1ZXJ5OiBzZWFyY2hQYXJhbXMuZ2V0KCdxJykgfHwgdW5kZWZpbmVkLFxuICAgICAgICBjYXRlZ29yeTogc2VhcmNoUGFyYW1zLmdldCgnY2F0ZWdvcnknKSB8fCB1bmRlZmluZWQsXG4gICAgICAgIHN0YXR1czogc2VhcmNoUGFyYW1zLmdldCgnc3RhdHVzJykgfHwgdW5kZWZpbmVkLFxuICAgICAgICBjaXR5OiBzZWFyY2hQYXJhbXMuZ2V0KCdjaXR5JykgfHwgdW5kZWZpbmVkLFxuICAgIH0pO1xuICAgIGNvbnN0IFtyZXN1bHRzLCBzZXRSZXN1bHRzXSA9IHVzZVN0YXRlPGFueVtdPihbXSk7XG4gICAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IFtzdWdnZXN0aW9ucywgc2V0U3VnZ2VzdGlvbnNdID0gdXNlU3RhdGU8c3RyaW5nW10+KFtdKTtcbiAgICBjb25zdCBbc2hvd1N1Z2dlc3Rpb25zLCBzZXRTaG93U3VnZ2VzdGlvbnNdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgLy8gRGVib3VuY2VkIHNlYXJjaCBmdW5jdGlvblxuICAgIGNvbnN0IGRlYm91bmNlZFNlYXJjaCA9IHVzZUNhbGxiYWNrKFxuICAgICAgICBkZWJvdW5jZShhc3luYyAoc2VhcmNoRmlsdGVyczogU2VhcmNoRmlsdGVycykgPT4ge1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzZWFyY2hQcm9kdWN0cyhzZWFyY2hGaWx0ZXJzKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzICYmIHJlc3BvbnNlLnByb2R1Y3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFJlc3VsdHMocmVzcG9uc2UucHJvZHVjdHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEVycm9yKHJlc3BvbnNlLmVycm9yIHx8ICdTZWFyY2ggZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIHNldFJlc3VsdHMoW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKCdTZWFyY2ggZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgc2V0UmVzdWx0cyhbXSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMCksXG4gICAgICAgIFtdXG4gICAgKTtcblxuICAgIC8vIFVwZGF0ZSBVUkwgd2l0aCBzZWFyY2ggcGFyYW1ldGVyc1xuICAgIGNvbnN0IHVwZGF0ZVVSTCA9IHVzZUNhbGxiYWNrKChuZXdGaWx0ZXJzOiBTZWFyY2hGaWx0ZXJzKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcblxuICAgICAgICBpZiAobmV3RmlsdGVycy5xdWVyeSkgcGFyYW1zLnNldCgncScsIG5ld0ZpbHRlcnMucXVlcnkpO1xuICAgICAgICBpZiAobmV3RmlsdGVycy5jYXRlZ29yeSkgcGFyYW1zLnNldCgnY2F0ZWdvcnknLCBuZXdGaWx0ZXJzLmNhdGVnb3J5KTtcbiAgICAgICAgaWYgKG5ld0ZpbHRlcnMuc3RhdHVzKSBwYXJhbXMuc2V0KCdzdGF0dXMnLCBuZXdGaWx0ZXJzLnN0YXR1cyk7XG4gICAgICAgIGlmIChuZXdGaWx0ZXJzLmNpdHkpIHBhcmFtcy5zZXQoJ2NpdHknLCBuZXdGaWx0ZXJzLmNpdHkpO1xuXG4gICAgICAgIGNvbnN0IG5ld1VSTCA9IHBhcmFtcy50b1N0cmluZygpID8gYC9zZWFyY2g/JHtwYXJhbXMudG9TdHJpbmcoKX1gIDogJy9zZWFyY2gnO1xuICAgICAgICByb3V0ZXIucHVzaChuZXdVUkwpO1xuICAgIH0sIFtyb3V0ZXJdKTtcblxuICAgIC8vIEhhbmRsZSBzZWFyY2ggaW5wdXRcbiAgICBjb25zdCBoYW5kbGVTZWFyY2ggPSB1c2VDYWxsYmFjaygoc2VhcmNoUXVlcnk6IHN0cmluZykgPT4ge1xuICAgICAgICBzZXRRdWVyeShzZWFyY2hRdWVyeSk7XG4gICAgICAgIGNvbnN0IG5ld0ZpbHRlcnMgPSB7IC4uLmZpbHRlcnMsIHF1ZXJ5OiBzZWFyY2hRdWVyeSB9O1xuICAgICAgICBzZXRGaWx0ZXJzKG5ld0ZpbHRlcnMpO1xuICAgICAgICB1cGRhdGVVUkwobmV3RmlsdGVycyk7XG4gICAgICAgIGRlYm91bmNlZFNlYXJjaChuZXdGaWx0ZXJzKTtcbiAgICB9LCBbZmlsdGVycywgdXBkYXRlVVJMLCBkZWJvdW5jZWRTZWFyY2hdKTtcblxuICAgIC8vIEhhbmRsZSBmaWx0ZXIgY2hhbmdlc1xuICAgIGNvbnN0IGhhbmRsZUZpbHRlckNoYW5nZSA9IHVzZUNhbGxiYWNrKChrZXk6IGtleW9mIFNlYXJjaEZpbHRlcnMsIHZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgY29uc3QgbmV3RmlsdGVycyA9IHsgLi4uZmlsdGVycywgW2tleV06IHZhbHVlIH07XG4gICAgICAgIHNldEZpbHRlcnMobmV3RmlsdGVycyk7XG4gICAgICAgIHVwZGF0ZVVSTChuZXdGaWx0ZXJzKTtcbiAgICAgICAgZGVib3VuY2VkU2VhcmNoKG5ld0ZpbHRlcnMpO1xuICAgIH0sIFtmaWx0ZXJzLCB1cGRhdGVVUkwsIGRlYm91bmNlZFNlYXJjaF0pO1xuXG4gICAgLy8gQ2xlYXIgYWxsIGZpbHRlcnNcbiAgICBjb25zdCBjbGVhckZpbHRlcnMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0ZpbHRlcnM6IFNlYXJjaEZpbHRlcnMgPSB7IHF1ZXJ5OiAnJyB9O1xuICAgICAgICBzZXRGaWx0ZXJzKG5ld0ZpbHRlcnMpO1xuICAgICAgICBzZXRRdWVyeSgnJyk7XG4gICAgICAgIHVwZGF0ZVVSTChuZXdGaWx0ZXJzKTtcbiAgICAgICAgZGVib3VuY2VkU2VhcmNoKG5ld0ZpbHRlcnMpO1xuICAgIH0sIFt1cGRhdGVVUkwsIGRlYm91bmNlZFNlYXJjaF0pO1xuXG4gICAgLy8gR2V0IHN1Z2dlc3Rpb25zIGZvciBjdXJyZW50IHF1ZXJ5XG4gICAgY29uc3QgdXBkYXRlU3VnZ2VzdGlvbnMgPSB1c2VDYWxsYmFjayhhc3luYyAoc2VhcmNoUXVlcnk6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoc2VhcmNoUXVlcnkubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N1Z2dlc3Rpb25zID0gYXdhaXQgZ2V0U2VhcmNoU3VnZ2VzdGlvbnMoc2VhcmNoUXVlcnkpO1xuICAgICAgICAgICAgc2V0U3VnZ2VzdGlvbnMobmV3U3VnZ2VzdGlvbnMpO1xuICAgICAgICAgICAgc2V0U2hvd1N1Z2dlc3Rpb25zKHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0U3VnZ2VzdGlvbnMoW10pO1xuICAgICAgICAgICAgc2V0U2hvd1N1Z2dlc3Rpb25zKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIERlYm91bmNlZCBzdWdnZXN0aW9uIHVwZGF0ZVxuICAgIGNvbnN0IGRlYm91bmNlZFN1Z2dlc3Rpb25zID0gdXNlQ2FsbGJhY2soXG4gICAgICAgIGRlYm91bmNlKHVwZGF0ZVN1Z2dlc3Rpb25zLCAyMDApLFxuICAgICAgICBbdXBkYXRlU3VnZ2VzdGlvbnNdXG4gICAgKTtcblxuICAgIC8vIEhhbmRsZSBpbnB1dCBjaGFuZ2Ugd2l0aCBzdWdnZXN0aW9uc1xuICAgIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gdXNlQ2FsbGJhY2soKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgc2V0UXVlcnkodmFsdWUpO1xuICAgICAgICBkZWJvdW5jZWRTdWdnZXN0aW9ucyh2YWx1ZSk7XG4gICAgfSwgW2RlYm91bmNlZFN1Z2dlc3Rpb25zXSk7XG5cbiAgICAvLyBTZWxlY3Qgc3VnZ2VzdGlvblxuICAgIGNvbnN0IHNlbGVjdFN1Z2dlc3Rpb24gPSB1c2VDYWxsYmFjaygoc3VnZ2VzdGlvbjogc3RyaW5nKSA9PiB7XG4gICAgICAgIHNldFF1ZXJ5KHN1Z2dlc3Rpb24pO1xuICAgICAgICBzZXRTaG93U3VnZ2VzdGlvbnMoZmFsc2UpO1xuICAgICAgICBoYW5kbGVTZWFyY2goc3VnZ2VzdGlvbik7XG4gICAgfSwgW2hhbmRsZVNlYXJjaF0pO1xuXG4gICAgLy8gSW5pdGlhbCBzZWFyY2ggb24gbW91bnRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZmlsdGVycy5xdWVyeSB8fCBmaWx0ZXJzLmNhdGVnb3J5IHx8IGZpbHRlcnMuc3RhdHVzIHx8IGZpbHRlcnMuY2l0eSkge1xuICAgICAgICAgICAgZGVib3VuY2VkU2VhcmNoKGZpbHRlcnMpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgLy8gTWVtb2l6ZWQgZmlsdGVyIGNvdW50c1xuICAgIGNvbnN0IGFjdGl2ZUZpbHRlcnNDb3VudCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhmaWx0ZXJzKS5maWx0ZXIodmFsdWUgPT4gdmFsdWUgJiYgdmFsdWUgIT09ICcnKS5sZW5ndGg7XG4gICAgfSwgW2ZpbHRlcnNdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8vIFN0YXRlXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBmaWx0ZXJzLFxuICAgICAgICByZXN1bHRzLFxuICAgICAgICBpc0xvYWRpbmcsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBzdWdnZXN0aW9ucyxcbiAgICAgICAgc2hvd1N1Z2dlc3Rpb25zLFxuICAgICAgICBhY3RpdmVGaWx0ZXJzQ291bnQsXG5cbiAgICAgICAgLy8gQWN0aW9uc1xuICAgICAgICBoYW5kbGVTZWFyY2gsXG4gICAgICAgIGhhbmRsZUlucHV0Q2hhbmdlLFxuICAgICAgICBoYW5kbGVGaWx0ZXJDaGFuZ2UsXG4gICAgICAgIGNsZWFyRmlsdGVycyxcbiAgICAgICAgc2VsZWN0U3VnZ2VzdGlvbixcbiAgICAgICAgc2V0U2hvd1N1Z2dlc3Rpb25zLFxuXG4gICAgICAgIC8vIEhlbHBlcnNcbiAgICAgICAgaGFzUmVzdWx0czogcmVzdWx0cy5sZW5ndGggPiAwLFxuICAgICAgICBoYXNGaWx0ZXJzOiBhY3RpdmVGaWx0ZXJzQ291bnQgPiAwLFxuICAgIH07XG59XG5cbi8vIFNpbXBsZSBkZWJvdW5jZSB1dGlsaXR5XG5mdW5jdGlvbiBkZWJvdW5jZTxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxuICAgIGZ1bmM6IFQsXG4gICAgd2FpdDogbnVtYmVyXG4pOiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4gdm9pZCB7XG4gICAgbGV0IHRpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0O1xuICAgIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGZ1bmMoLi4uYXJncyksIHdhaXQpO1xuICAgIH07XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsInVzZU1lbW8iLCJ1c2VSb3V0ZXIiLCJ1c2VTZWFyY2hQYXJhbXMiLCJzZWFyY2hQcm9kdWN0cyIsImdldFNlYXJjaFN1Z2dlc3Rpb25zIiwidXNlR2xvYmFsTG9hZGluZyIsInVzZVNlYXJjaCIsInJvdXRlciIsInNlYXJjaFBhcmFtcyIsInNob3dMb2FkaW5nIiwiaGlkZUxvYWRpbmciLCJxdWVyeSIsInNldFF1ZXJ5IiwiZ2V0IiwiZmlsdGVycyIsInNldEZpbHRlcnMiLCJ1bmRlZmluZWQiLCJjYXRlZ29yeSIsInN0YXR1cyIsImNpdHkiLCJyZXN1bHRzIiwic2V0UmVzdWx0cyIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJzdWdnZXN0aW9ucyIsInNldFN1Z2dlc3Rpb25zIiwic2hvd1N1Z2dlc3Rpb25zIiwic2V0U2hvd1N1Z2dlc3Rpb25zIiwiZGVib3VuY2VkU2VhcmNoIiwiZGVib3VuY2UiLCJzZWFyY2hGaWx0ZXJzIiwicmVzcG9uc2UiLCJzdWNjZXNzIiwicHJvZHVjdHMiLCJlcnIiLCJ1cGRhdGVVUkwiLCJuZXdGaWx0ZXJzIiwicGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwic2V0IiwibmV3VVJMIiwidG9TdHJpbmciLCJwdXNoIiwiaGFuZGxlU2VhcmNoIiwic2VhcmNoUXVlcnkiLCJoYW5kbGVGaWx0ZXJDaGFuZ2UiLCJrZXkiLCJ2YWx1ZSIsImNsZWFyRmlsdGVycyIsInVwZGF0ZVN1Z2dlc3Rpb25zIiwibGVuZ3RoIiwibmV3U3VnZ2VzdGlvbnMiLCJkZWJvdW5jZWRTdWdnZXN0aW9ucyIsImhhbmRsZUlucHV0Q2hhbmdlIiwic2VsZWN0U3VnZ2VzdGlvbiIsInN1Z2dlc3Rpb24iLCJhY3RpdmVGaWx0ZXJzQ291bnQiLCJPYmplY3QiLCJ2YWx1ZXMiLCJmaWx0ZXIiLCJoYXNSZXN1bHRzIiwiaGFzRmlsdGVycyIsImZ1bmMiLCJ3YWl0IiwidGltZW91dCIsImFyZ3MiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useSearch.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/search.ts":
/*!***************************!*\
  !*** ./src/lib/search.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getSearchSuggestions: () => (/* binding */ getSearchSuggestions),\n/* harmony export */   getTrendingSearches: () => (/* binding */ getTrendingSearches),\n/* harmony export */   searchProducts: () => (/* binding */ searchProducts)\n/* harmony export */ });\n/* harmony import */ var _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/integrations/supabase/client */ \"(app-pages-browser)/./src/integrations/supabase/client.ts\");\n\n// Client-side search function\nasync function searchProducts(filters) {\n    try {\n        let query = _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('products').select(\"\\n        id,\\n        title,\\n        price_pence,\\n        status,\\n        images,\\n        city,\\n        category,\\n        user_id,\\n        profiles:profiles!products_user_id_fkey(\\n          handle,\\n          name,\\n          avatar_url\\n        )\\n      \");\n        // Apply text search\n        if (filters.query) {\n            query = query.or(\"title.ilike.%\".concat(filters.query, \"%,city.ilike.%\").concat(filters.query, \"%\"));\n        }\n        // Apply category filter\n        if (filters.category) {\n            query = query.eq('category', filters.category.toUpperCase());\n        }\n        // Apply status filter\n        if (filters.status) {\n            query = query.eq('status', filters.status.toUpperCase());\n        }\n        // Apply city filter\n        if (filters.city) {\n            query = query.ilike('city', \"%\".concat(filters.city, \"%\"));\n        }\n        // Apply price filters\n        if (filters.minPrice !== undefined) {\n            query = query.gte('price_pence', filters.minPrice);\n        }\n        if (filters.maxPrice !== undefined) {\n            query = query.lte('price_pence', filters.maxPrice);\n        }\n        // Order by relevance and date\n        query = query.order('created_at', {\n            ascending: false\n        });\n        // Limit results\n        query = query.limit(50);\n        const { data, error, count } = await query;\n        if (error) {\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n        return {\n            success: true,\n            products: data || [],\n            total: count || 0\n        };\n    } catch (error) {\n        console.error('Search error:', error);\n        return {\n            success: false,\n            error: 'Failed to search products'\n        };\n    }\n}\n// Get trending search terms (mock data for now)\nfunction getTrendingSearches() {\n    return [\n        'jollof rice',\n        'ankara fabric',\n        'shea butter',\n        'garri',\n        'african wigs',\n        'spices'\n    ];\n}\n// Get search suggestions based on partial input\nasync function getSearchSuggestions(query) {\n    if (query.length < 2) return [];\n    try {\n        // Search product titles for suggestions\n        const { data, error } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('products').select('title').ilike('title', \"%\".concat(query, \"%\")).limit(5);\n        if (error) {\n            console.error('Suggestion error:', error);\n            return [];\n        }\n        return (data === null || data === void 0 ? void 0 : data.map((item)=>item.title)) || [];\n    } catch (error) {\n        console.error('Suggestion error:', error);\n        return [];\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZXJzL2lmZWRheW9hZ2Jvb2xhL0Rlc2t0b3AvbXlQcm9qZWN0cy9ldGhuaXFyb290ei1uZXh0anMvc3JjL2xpYi9zZWFyY2gudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICdAL2ludGVncmF0aW9ucy9zdXBhYmFzZS9jbGllbnQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaEZpbHRlcnMge1xuICAgIHF1ZXJ5Pzogc3RyaW5nO1xuICAgIGNhdGVnb3J5Pzogc3RyaW5nO1xuICAgIHN0YXR1cz86IHN0cmluZztcbiAgICBjaXR5Pzogc3RyaW5nO1xuICAgIG1pblByaWNlPzogbnVtYmVyO1xuICAgIG1heFByaWNlPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaFJlc3VsdCB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIHByaWNlX3BlbmNlOiBudW1iZXI7XG4gICAgc3RhdHVzOiBzdHJpbmc7XG4gICAgaW1hZ2VzOiBzdHJpbmdbXTtcbiAgICBjaXR5OiBzdHJpbmc7XG4gICAgY2F0ZWdvcnk6IHN0cmluZztcbiAgICB1c2VyX2lkOiBzdHJpbmc7XG4gICAgcHJvZmlsZXM6IHtcbiAgICAgICAgaGFuZGxlOiBzdHJpbmc7XG4gICAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgICAgYXZhdGFyX3VybDogc3RyaW5nO1xuICAgIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoUmVzcG9uc2Uge1xuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XG4gICAgcHJvZHVjdHM/OiBTZWFyY2hSZXN1bHRbXTtcbiAgICBlcnJvcj86IHN0cmluZztcbiAgICB0b3RhbD86IG51bWJlcjtcbn1cblxuLy8gQ2xpZW50LXNpZGUgc2VhcmNoIGZ1bmN0aW9uXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VhcmNoUHJvZHVjdHMoZmlsdGVyczogU2VhcmNoRmlsdGVycyk6IFByb21pc2U8U2VhcmNoUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgcXVlcnkgPSBzdXBhYmFzZVxuICAgICAgICAgICAgLmZyb20oJ3Byb2R1Y3RzJylcbiAgICAgICAgICAgIC5zZWxlY3QoYFxuICAgICAgICBpZCxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIHByaWNlX3BlbmNlLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGltYWdlcyxcbiAgICAgICAgY2l0eSxcbiAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgIHVzZXJfaWQsXG4gICAgICAgIHByb2ZpbGVzOnByb2ZpbGVzIXByb2R1Y3RzX3VzZXJfaWRfZmtleShcbiAgICAgICAgICBoYW5kbGUsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBhdmF0YXJfdXJsXG4gICAgICAgIClcbiAgICAgIGApO1xuXG4gICAgICAgIC8vIEFwcGx5IHRleHQgc2VhcmNoXG4gICAgICAgIGlmIChmaWx0ZXJzLnF1ZXJ5KSB7XG4gICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm9yKGB0aXRsZS5pbGlrZS4lJHtmaWx0ZXJzLnF1ZXJ5fSUsY2l0eS5pbGlrZS4lJHtmaWx0ZXJzLnF1ZXJ5fSVgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGx5IGNhdGVnb3J5IGZpbHRlclxuICAgICAgICBpZiAoZmlsdGVycy5jYXRlZ29yeSkge1xuICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5lcSgnY2F0ZWdvcnknLCBmaWx0ZXJzLmNhdGVnb3J5LnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgc3RhdHVzIGZpbHRlclxuICAgICAgICBpZiAoZmlsdGVycy5zdGF0dXMpIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuZXEoJ3N0YXR1cycsIGZpbHRlcnMuc3RhdHVzLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgY2l0eSBmaWx0ZXJcbiAgICAgICAgaWYgKGZpbHRlcnMuY2l0eSkge1xuICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5pbGlrZSgnY2l0eScsIGAlJHtmaWx0ZXJzLmNpdHl9JWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwbHkgcHJpY2UgZmlsdGVyc1xuICAgICAgICBpZiAoZmlsdGVycy5taW5QcmljZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lmd0ZSgncHJpY2VfcGVuY2UnLCBmaWx0ZXJzLm1pblByaWNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVycy5tYXhQcmljZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5Lmx0ZSgncHJpY2VfcGVuY2UnLCBmaWx0ZXJzLm1heFByaWNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9yZGVyIGJ5IHJlbGV2YW5jZSBhbmQgZGF0ZVxuICAgICAgICBxdWVyeSA9IHF1ZXJ5Lm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuXG4gICAgICAgIC8vIExpbWl0IHJlc3VsdHNcbiAgICAgICAgcXVlcnkgPSBxdWVyeS5saW1pdCg1MCk7XG5cbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciwgY291bnQgfSA9IGF3YWl0IHF1ZXJ5O1xuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIHByb2R1Y3RzOiBkYXRhIHx8IFtdLFxuICAgICAgICAgICAgdG90YWw6IGNvdW50IHx8IDBcbiAgICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTZWFyY2ggZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byBzZWFyY2ggcHJvZHVjdHMnXG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vLyBHZXQgdHJlbmRpbmcgc2VhcmNoIHRlcm1zIChtb2NrIGRhdGEgZm9yIG5vdylcbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmVuZGluZ1NlYXJjaGVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gWydqb2xsb2YgcmljZScsICdhbmthcmEgZmFicmljJywgJ3NoZWEgYnV0dGVyJywgJ2dhcnJpJywgJ2FmcmljYW4gd2lncycsICdzcGljZXMnXTtcbn1cblxuLy8gR2V0IHNlYXJjaCBzdWdnZXN0aW9ucyBiYXNlZCBvbiBwYXJ0aWFsIGlucHV0XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U2VhcmNoU3VnZ2VzdGlvbnMocXVlcnk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBpZiAocXVlcnkubGVuZ3RoIDwgMikgcmV0dXJuIFtdO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gU2VhcmNoIHByb2R1Y3QgdGl0bGVzIGZvciBzdWdnZXN0aW9uc1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLmZyb20oJ3Byb2R1Y3RzJylcbiAgICAgICAgICAgIC5zZWxlY3QoJ3RpdGxlJylcbiAgICAgICAgICAgIC5pbGlrZSgndGl0bGUnLCBgJSR7cXVlcnl9JWApXG4gICAgICAgICAgICAubGltaXQoNSk7XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdTdWdnZXN0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhPy5tYXAoaXRlbSA9PiBpdGVtLnRpdGxlKSB8fCBbXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTdWdnZXN0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJzdXBhYmFzZSIsInNlYXJjaFByb2R1Y3RzIiwiZmlsdGVycyIsInF1ZXJ5IiwiZnJvbSIsInNlbGVjdCIsIm9yIiwiY2F0ZWdvcnkiLCJlcSIsInRvVXBwZXJDYXNlIiwic3RhdHVzIiwiY2l0eSIsImlsaWtlIiwibWluUHJpY2UiLCJ1bmRlZmluZWQiLCJndGUiLCJtYXhQcmljZSIsImx0ZSIsIm9yZGVyIiwiYXNjZW5kaW5nIiwibGltaXQiLCJkYXRhIiwiZXJyb3IiLCJjb3VudCIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwicHJvZHVjdHMiLCJ0b3RhbCIsImNvbnNvbGUiLCJnZXRUcmVuZGluZ1NlYXJjaGVzIiwiZ2V0U2VhcmNoU3VnZ2VzdGlvbnMiLCJsZW5ndGgiLCJtYXAiLCJpdGVtIiwidGl0bGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/search.ts\n"));

/***/ })

});