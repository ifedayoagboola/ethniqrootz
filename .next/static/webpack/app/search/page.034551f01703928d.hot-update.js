"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/search/page",{

/***/ "(app-pages-browser)/./src/lib/saves.ts":
/*!**************************!*\
  !*** ./src/lib/saves.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   batchGetProductsSaveData: () => (/* binding */ batchGetProductsSaveData),\n/* harmony export */   batchToggleSaves: () => (/* binding */ batchToggleSaves),\n/* harmony export */   clearSaveCache: () => (/* binding */ clearSaveCache),\n/* harmony export */   getProductSaveCount: () => (/* binding */ getProductSaveCount),\n/* harmony export */   getUserSavedProducts: () => (/* binding */ getUserSavedProducts),\n/* harmony export */   getUserSavedProductsWithMetadata: () => (/* binding */ getUserSavedProductsWithMetadata),\n/* harmony export */   isProductSaved: () => (/* binding */ isProductSaved),\n/* harmony export */   saveProduct: () => (/* binding */ saveProduct),\n/* harmony export */   unsaveProduct: () => (/* binding */ unsaveProduct)\n/* harmony export */ });\n/* harmony import */ var _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/integrations/supabase/client */ \"(app-pages-browser)/./src/integrations/supabase/client.ts\");\n\n// Request throttling and caching\nconst requestCache = new Map();\nconst pendingRequests = new Map();\nconst REQUEST_CACHE_DURATION = 30000; // 30 seconds\nconst REQUEST_THROTTLE_DELAY = 1000; // 1 second between requests\n// Throttled request helper with retry logic\nasync function throttledRequest(key, requestFn) {\n    let useCache = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true, maxRetries = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 2;\n    // Check cache first\n    if (useCache) {\n        const cached = requestCache.get(key);\n        if (cached && Date.now() - cached.timestamp < REQUEST_CACHE_DURATION) {\n            return cached.data;\n        }\n    }\n    // Check if request is already pending\n    if (pendingRequests.has(key)) {\n        return pendingRequests.get(key);\n    }\n    // Create new request with retry logic\n    const requestPromise = new Promise(async (resolve, reject)=>{\n        let attempts = 0;\n        const attemptRequest = async ()=>{\n            try {\n                attempts++;\n                const result = await requestFn();\n                if (useCache) {\n                    requestCache.set(key, {\n                        data: result,\n                        timestamp: Date.now()\n                    });\n                }\n                resolve(result);\n            } catch (error) {\n                if (attempts < maxRetries && shouldRetry(error)) {\n                    // Exponential backoff: 500ms, 1000ms, 2000ms\n                    const delay = 500 * Math.pow(2, attempts - 1);\n                    setTimeout(attemptRequest, delay);\n                } else {\n                    reject(error);\n                }\n            } finally{\n                if (attempts >= maxRetries) {\n                    pendingRequests.delete(key);\n                }\n            }\n        };\n        // Initial delay for throttling\n        setTimeout(attemptRequest, REQUEST_THROTTLE_DELAY);\n    });\n    pendingRequests.set(key, requestPromise);\n    return requestPromise;\n}\n// Helper to determine if an error should trigger a retry\nfunction shouldRetry(error) {\n    var _error_message;\n    if (!error) return false;\n    // Retry on network errors or connection issues\n    const message = ((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.toLowerCase()) || '';\n    return message.includes('network') || message.includes('connection') || message.includes('timeout') || message.includes('err_connection_closed') || message.includes('err_failed');\n}\n// Cache invalidation helper\nfunction invalidateCache(pattern) {\n    const keysToDelete = [];\n    requestCache.forEach((_, key)=>{\n        if (key.includes(pattern)) {\n            keysToDelete.push(key);\n        }\n    });\n    keysToDelete.forEach((key)=>requestCache.delete(key));\n}\n// Clear all cache (useful for logout or major state changes)\nfunction clearSaveCache() {\n    requestCache.clear();\n    pendingRequests.clear();\n}\n// Enhanced client-side save operations with better error handling and performance\nasync function saveProduct(productId) {\n    try {\n        const { data: { user } } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) {\n            return {\n                success: false,\n                error: 'User not authenticated'\n            };\n        }\n        const { error } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('saves').insert({\n            user_id: user.id,\n            product_id: productId\n        });\n        if (error) {\n            // Handle unique constraint violation gracefully\n            if (error.code === '23505') {\n                return {\n                    success: true,\n                    saveCount: 0\n                }; // Already saved\n            }\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n        // Invalidate cache for this product\n        invalidateCache(productId);\n        // Get updated save count\n        const { data: countData, error: countError } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc('get_product_save_count', {\n            product_uuid: productId\n        });\n        if (countError) {\n            console.error('Error getting save count:', countError);\n        }\n        return {\n            success: true,\n            saveCount: countData || 0\n        };\n    } catch (error) {\n        console.error('Error saving product:', error);\n        return {\n            success: false,\n            error: 'Failed to save product'\n        };\n    }\n}\nasync function unsaveProduct(productId) {\n    try {\n        const { data: { user } } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) {\n            return {\n                success: false,\n                error: 'User not authenticated'\n            };\n        }\n        const { error } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('saves').delete().eq('product_id', productId).eq('user_id', user.id);\n        if (error) {\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n        // Invalidate cache for this product\n        invalidateCache(productId);\n        // Get updated save count\n        const { data: countData, error: countError } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc('get_product_save_count', {\n            product_uuid: productId\n        });\n        if (countError) {\n            console.error('Error getting save count:', countError);\n        }\n        return {\n            success: true,\n            saveCount: countData || 0\n        };\n    } catch (error) {\n        console.error('Error unsaving product:', error);\n        return {\n            success: false,\n            error: 'Failed to unsave product'\n        };\n    }\n}\nasync function getUserSavedProducts() {\n    try {\n        const { data: { user } } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) {\n            return {\n                success: false,\n                error: 'User not authenticated'\n            };\n        }\n        const { data, error } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.from('saves').select('product_id').eq('user_id', user.id).order('created_at', {\n            ascending: false\n        });\n        if (error) {\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n        const productIds = (data === null || data === void 0 ? void 0 : data.map((item)=>item.product_id)) || [];\n        return {\n            success: true,\n            productIds\n        };\n    } catch (error) {\n        console.error('Error getting saved products:', error);\n        return {\n            success: false,\n            error: 'Failed to get saved products'\n        };\n    }\n}\nasync function getProductSaveCount(productId) {\n    const cacheKey = \"save_count_\".concat(productId);\n    return throttledRequest(cacheKey, async ()=>{\n        try {\n            const { data, error } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc('get_product_save_count', {\n                product_uuid: productId\n            });\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true,\n                count: data || 0\n            };\n        } catch (error) {\n            console.error('Error getting save count:', error);\n            return {\n                success: false,\n                error: 'Failed to get save count'\n            };\n        }\n    });\n}\nasync function isProductSaved(productId) {\n    const { data: { user } } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n    if (!user) {\n        return {\n            success: false,\n            error: 'User not authenticated'\n        };\n    }\n    const cacheKey = \"is_saved_\".concat(productId, \"_\").concat(user.id);\n    return throttledRequest(cacheKey, async ()=>{\n        try {\n            const { data, error } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc('is_product_saved_by_user', {\n                product_uuid: productId,\n                user_uuid: user.id\n            });\n            if (error) {\n                return {\n                    success: false,\n                    error: error.message\n                };\n            }\n            return {\n                success: true,\n                isSaved: data || false\n            };\n        } catch (error) {\n            console.error('Error checking if product is saved:', error);\n            return {\n                success: false,\n                error: 'Failed to check save status'\n            };\n        }\n    });\n}\n// NEW: Batch operations for better performance\nasync function batchGetProductsSaveData(productIds) {\n    try {\n        const { data: { user } } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) {\n            return {\n                success: false,\n                error: 'User not authenticated'\n            };\n        }\n        const { data, error } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc('get_products_save_data', {\n            product_uuids: productIds,\n            user_uuid: user.id\n        });\n        if (error) {\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n        const saveData = (data === null || data === void 0 ? void 0 : data.map((item)=>({\n                productId: item.product_id,\n                isSaved: item.is_saved,\n                saveCount: item.save_count\n            }))) || [];\n        return {\n            success: true,\n            data: saveData\n        };\n    } catch (error) {\n        console.error('Error getting batch save data:', error);\n        return {\n            success: false,\n            error: 'Failed to get batch save data'\n        };\n    }\n}\nasync function batchToggleSaves(productIds, action) {\n    try {\n        const { data: { user } } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) {\n            return {\n                success: false,\n                error: 'User not authenticated'\n            };\n        }\n        const { data, error } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc('batch_toggle_saves', {\n            product_uuids: productIds,\n            user_uuid: user.id,\n            action: action\n        });\n        if (error) {\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n        const results = (data === null || data === void 0 ? void 0 : data.map((item)=>({\n                productId: item.product_id,\n                isSaved: action === 'save',\n                saveCount: item.new_save_count\n            }))) || [];\n        return {\n            success: true,\n            results\n        };\n    } catch (error) {\n        console.error('Error batch toggling saves:', error);\n        return {\n            success: false,\n            error: 'Failed to batch toggle saves'\n        };\n    }\n}\n// NEW: Get saved products with metadata for a dedicated saved page\nasync function getUserSavedProductsWithMetadata() {\n    try {\n        const { data: { user } } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();\n        if (!user) {\n            return {\n                success: false,\n                error: 'User not authenticated'\n            };\n        }\n        const { data, error } = await _integrations_supabase_client__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc('get_user_saved_products_with_metadata', {\n            user_uuid: user.id\n        });\n        if (error) {\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n        const products = (data === null || data === void 0 ? void 0 : data.map((item)=>({\n                productId: item.product_id,\n                savedAt: item.saved_at,\n                productTitle: item.product_title,\n                productPricePence: item.product_price_pence,\n                productImages: item.product_images || []\n            }))) || [];\n        return {\n            success: true,\n            products\n        };\n    } catch (error) {\n        console.error('Error getting saved products with metadata:', error);\n        return {\n            success: false,\n            error: 'Failed to get saved products with metadata'\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1lBQ0h1QixTQUFTO1lBQ1R2QixPQUFPO1FBQ1g7SUFDSjtBQUNKIiwic291cmNlcyI6WyIvVXNlcnMvaWZlZGF5b2FnYm9vbGEvRGVza3RvcC9teVByb2plY3RzL2V0aG5pcXJvb3R6LW5leHRqcy9zcmMvbGliL3NhdmVzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHN1cGFiYXNlIH0gZnJvbSAnQC9pbnRlZ3JhdGlvbnMvc3VwYWJhc2UvY2xpZW50JztcblxuLy8gUmVxdWVzdCB0aHJvdHRsaW5nIGFuZCBjYWNoaW5nXG5jb25zdCByZXF1ZXN0Q2FjaGUgPSBuZXcgTWFwPHN0cmluZywgeyBkYXRhOiBhbnk7IHRpbWVzdGFtcDogbnVtYmVyIH0+KCk7XG5jb25zdCBwZW5kaW5nUmVxdWVzdHMgPSBuZXcgTWFwPHN0cmluZywgUHJvbWlzZTxhbnk+PigpO1xuY29uc3QgUkVRVUVTVF9DQUNIRV9EVVJBVElPTiA9IDMwMDAwOyAvLyAzMCBzZWNvbmRzXG5jb25zdCBSRVFVRVNUX1RIUk9UVExFX0RFTEFZID0gMTAwMDsgLy8gMSBzZWNvbmQgYmV0d2VlbiByZXF1ZXN0c1xuXG4vLyBUaHJvdHRsZWQgcmVxdWVzdCBoZWxwZXIgd2l0aCByZXRyeSBsb2dpY1xuYXN5bmMgZnVuY3Rpb24gdGhyb3R0bGVkUmVxdWVzdDxUPihcbiAgICBrZXk6IHN0cmluZyxcbiAgICByZXF1ZXN0Rm46ICgpID0+IFByb21pc2U8VD4sXG4gICAgdXNlQ2FjaGU6IGJvb2xlYW4gPSB0cnVlLFxuICAgIG1heFJldHJpZXM6IG51bWJlciA9IDJcbik6IFByb21pc2U8VD4ge1xuICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0XG4gICAgaWYgKHVzZUNhY2hlKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IHJlcXVlc3RDYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGNhY2hlZCAmJiBEYXRlLm5vdygpIC0gY2FjaGVkLnRpbWVzdGFtcCA8IFJFUVVFU1RfQ0FDSEVfRFVSQVRJT04pIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQuZGF0YTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHJlcXVlc3QgaXMgYWxyZWFkeSBwZW5kaW5nXG4gICAgaWYgKHBlbmRpbmdSZXF1ZXN0cy5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gcGVuZGluZ1JlcXVlc3RzLmdldChrZXkpITtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbmV3IHJlcXVlc3Qgd2l0aCByZXRyeSBsb2dpY1xuICAgIGNvbnN0IHJlcXVlc3RQcm9taXNlID0gbmV3IFByb21pc2U8VD4oYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBsZXQgYXR0ZW1wdHMgPSAwO1xuXG4gICAgICAgIGNvbnN0IGF0dGVtcHRSZXF1ZXN0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhdHRlbXB0cysrO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVlc3RGbigpO1xuICAgICAgICAgICAgICAgIGlmICh1c2VDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Q2FjaGUuc2V0KGtleSwgeyBkYXRhOiByZXN1bHQsIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdHMgPCBtYXhSZXRyaWVzICYmIHNob3VsZFJldHJ5KGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHBvbmVudGlhbCBiYWNrb2ZmOiA1MDBtcywgMTAwMG1zLCAyMDAwbXNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsYXkgPSA1MDAgKiBNYXRoLnBvdygyLCBhdHRlbXB0cyAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGF0dGVtcHRSZXF1ZXN0LCBkZWxheSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0cyA+PSBtYXhSZXRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdSZXF1ZXN0cy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW5pdGlhbCBkZWxheSBmb3IgdGhyb3R0bGluZ1xuICAgICAgICBzZXRUaW1lb3V0KGF0dGVtcHRSZXF1ZXN0LCBSRVFVRVNUX1RIUk9UVExFX0RFTEFZKTtcbiAgICB9KTtcblxuICAgIHBlbmRpbmdSZXF1ZXN0cy5zZXQoa2V5LCByZXF1ZXN0UHJvbWlzZSk7XG4gICAgcmV0dXJuIHJlcXVlc3RQcm9taXNlO1xufVxuXG4vLyBIZWxwZXIgdG8gZGV0ZXJtaW5lIGlmIGFuIGVycm9yIHNob3VsZCB0cmlnZ2VyIGEgcmV0cnlcbmZ1bmN0aW9uIHNob3VsZFJldHJ5KGVycm9yOiBhbnkpOiBib29sZWFuIHtcbiAgICBpZiAoIWVycm9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBSZXRyeSBvbiBuZXR3b3JrIGVycm9ycyBvciBjb25uZWN0aW9uIGlzc3Vlc1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlPy50b0xvd2VyQ2FzZSgpIHx8ICcnO1xuICAgIHJldHVybiBtZXNzYWdlLmluY2x1ZGVzKCduZXR3b3JrJykgfHxcbiAgICAgICAgbWVzc2FnZS5pbmNsdWRlcygnY29ubmVjdGlvbicpIHx8XG4gICAgICAgIG1lc3NhZ2UuaW5jbHVkZXMoJ3RpbWVvdXQnKSB8fFxuICAgICAgICBtZXNzYWdlLmluY2x1ZGVzKCdlcnJfY29ubmVjdGlvbl9jbG9zZWQnKSB8fFxuICAgICAgICBtZXNzYWdlLmluY2x1ZGVzKCdlcnJfZmFpbGVkJyk7XG59XG5cbi8vIENhY2hlIGludmFsaWRhdGlvbiBoZWxwZXJcbmZ1bmN0aW9uIGludmFsaWRhdGVDYWNoZShwYXR0ZXJuOiBzdHJpbmcpIHtcbiAgICBjb25zdCBrZXlzVG9EZWxldGU6IHN0cmluZ1tdID0gW107XG4gICAgcmVxdWVzdENhY2hlLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgICBpZiAoa2V5LmluY2x1ZGVzKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICBrZXlzVG9EZWxldGUucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAga2V5c1RvRGVsZXRlLmZvckVhY2goa2V5ID0+IHJlcXVlc3RDYWNoZS5kZWxldGUoa2V5KSk7XG59XG5cbi8vIENsZWFyIGFsbCBjYWNoZSAodXNlZnVsIGZvciBsb2dvdXQgb3IgbWFqb3Igc3RhdGUgY2hhbmdlcylcbmV4cG9ydCBmdW5jdGlvbiBjbGVhclNhdmVDYWNoZSgpIHtcbiAgICByZXF1ZXN0Q2FjaGUuY2xlYXIoKTtcbiAgICBwZW5kaW5nUmVxdWVzdHMuY2xlYXIoKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTYXZlUmVzdWx0IHtcbiAgICBzdWNjZXNzOiBib29sZWFuO1xuICAgIGVycm9yPzogc3RyaW5nO1xuICAgIHNhdmVDb3VudD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTYXZlRGF0YSB7XG4gICAgcHJvZHVjdElkOiBzdHJpbmc7XG4gICAgaXNTYXZlZDogYm9vbGVhbjtcbiAgICBzYXZlQ291bnQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXRjaFNhdmVSZXN1bHQge1xuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XG4gICAgZXJyb3I/OiBzdHJpbmc7XG4gICAgcmVzdWx0cz86IEFycmF5PHtcbiAgICAgICAgcHJvZHVjdElkOiBzdHJpbmc7XG4gICAgICAgIGlzU2F2ZWQ6IGJvb2xlYW47XG4gICAgICAgIHNhdmVDb3VudDogbnVtYmVyO1xuICAgIH0+O1xufVxuXG4vLyBFbmhhbmNlZCBjbGllbnQtc2lkZSBzYXZlIG9wZXJhdGlvbnMgd2l0aCBiZXR0ZXIgZXJyb3IgaGFuZGxpbmcgYW5kIHBlcmZvcm1hbmNlXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlUHJvZHVjdChwcm9kdWN0SWQ6IHN0cmluZyk6IFByb21pc2U8U2F2ZVJlc3VsdD4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ1VzZXIgbm90IGF1dGhlbnRpY2F0ZWQnIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLmZyb20oJ3NhdmVzJylcbiAgICAgICAgICAgIC5pbnNlcnQoeyB1c2VyX2lkOiB1c2VyLmlkLCBwcm9kdWN0X2lkOiBwcm9kdWN0SWQgfSk7XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgdW5pcXVlIGNvbnN0cmFpbnQgdmlvbGF0aW9uIGdyYWNlZnVsbHlcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSAnMjM1MDUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgc2F2ZUNvdW50OiAwIH07IC8vIEFscmVhZHkgc2F2ZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW52YWxpZGF0ZSBjYWNoZSBmb3IgdGhpcyBwcm9kdWN0XG4gICAgICAgIGludmFsaWRhdGVDYWNoZShwcm9kdWN0SWQpO1xuXG4gICAgICAgIC8vIEdldCB1cGRhdGVkIHNhdmUgY291bnRcbiAgICAgICAgY29uc3QgeyBkYXRhOiBjb3VudERhdGEsIGVycm9yOiBjb3VudEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLnJwYygnZ2V0X3Byb2R1Y3Rfc2F2ZV9jb3VudCcsIHsgcHJvZHVjdF91dWlkOiBwcm9kdWN0SWQgfSk7XG5cbiAgICAgICAgaWYgKGNvdW50RXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgc2F2ZSBjb3VudDonLCBjb3VudEVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgc2F2ZUNvdW50OiBjb3VudERhdGEgfHwgMFxuICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBwcm9kdWN0OicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdGYWlsZWQgdG8gc2F2ZSBwcm9kdWN0J1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVuc2F2ZVByb2R1Y3QocHJvZHVjdElkOiBzdHJpbmcpOiBQcm9taXNlPFNhdmVSZXN1bHQ+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdVc2VyIG5vdCBhdXRoZW50aWNhdGVkJyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCdzYXZlcycpXG4gICAgICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgICAgIC5lcSgncHJvZHVjdF9pZCcsIHByb2R1Y3RJZClcbiAgICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpO1xuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnZhbGlkYXRlIGNhY2hlIGZvciB0aGlzIHByb2R1Y3RcbiAgICAgICAgaW52YWxpZGF0ZUNhY2hlKHByb2R1Y3RJZCk7XG5cbiAgICAgICAgLy8gR2V0IHVwZGF0ZWQgc2F2ZSBjb3VudFxuICAgICAgICBjb25zdCB7IGRhdGE6IGNvdW50RGF0YSwgZXJyb3I6IGNvdW50RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAucnBjKCdnZXRfcHJvZHVjdF9zYXZlX2NvdW50JywgeyBwcm9kdWN0X3V1aWQ6IHByb2R1Y3RJZCB9KTtcblxuICAgICAgICBpZiAoY291bnRFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBzYXZlIGNvdW50OicsIGNvdW50RXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBzYXZlQ291bnQ6IGNvdW50RGF0YSB8fCAwXG4gICAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdW5zYXZpbmcgcHJvZHVjdDonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnRmFpbGVkIHRvIHVuc2F2ZSBwcm9kdWN0J1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJTYXZlZFByb2R1Y3RzKCk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBwcm9kdWN0SWRzPzogc3RyaW5nW107IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6ICdVc2VyIG5vdCBhdXRoZW50aWNhdGVkJyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCdzYXZlcycpXG4gICAgICAgICAgICAuc2VsZWN0KCdwcm9kdWN0X2lkJylcbiAgICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG4gICAgICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb2R1Y3RJZHMgPSBkYXRhPy5tYXAoKGl0ZW06IHsgcHJvZHVjdF9pZDogc3RyaW5nIH0pID0+IGl0ZW0ucHJvZHVjdF9pZCkgfHwgW107XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHByb2R1Y3RJZHMgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHNhdmVkIHByb2R1Y3RzOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdGYWlsZWQgdG8gZ2V0IHNhdmVkIHByb2R1Y3RzJ1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFByb2R1Y3RTYXZlQ291bnQocHJvZHVjdElkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgY291bnQ/OiBudW1iZXI7IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGBzYXZlX2NvdW50XyR7cHJvZHVjdElkfWA7XG5cbiAgICByZXR1cm4gdGhyb3R0bGVkUmVxdWVzdChjYWNoZUtleSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAucnBjKCdnZXRfcHJvZHVjdF9zYXZlX2NvdW50JywgeyBwcm9kdWN0X3V1aWQ6IHByb2R1Y3RJZCB9KTtcblxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGNvdW50OiBkYXRhIHx8IDAgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgc2F2ZSBjb3VudDonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiAnRmFpbGVkIHRvIGdldCBzYXZlIGNvdW50J1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNQcm9kdWN0U2F2ZWQocHJvZHVjdElkOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgaXNTYXZlZD86IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0+IHtcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9IH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIoKTtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnVXNlciBub3QgYXV0aGVudGljYXRlZCcgfTtcbiAgICB9XG5cbiAgICBjb25zdCBjYWNoZUtleSA9IGBpc19zYXZlZF8ke3Byb2R1Y3RJZH1fJHt1c2VyLmlkfWA7XG5cbiAgICByZXR1cm4gdGhyb3R0bGVkUmVxdWVzdChjYWNoZUtleSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAucnBjKCdpc19wcm9kdWN0X3NhdmVkX2J5X3VzZXInLCB7XG4gICAgICAgICAgICAgICAgICAgIHByb2R1Y3RfdXVpZDogcHJvZHVjdElkLFxuICAgICAgICAgICAgICAgICAgICB1c2VyX3V1aWQ6IHVzZXIuaWRcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGlzU2F2ZWQ6IGRhdGEgfHwgZmFsc2UgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGlmIHByb2R1Y3QgaXMgc2F2ZWQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byBjaGVjayBzYXZlIHN0YXR1cydcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLy8gTkVXOiBCYXRjaCBvcGVyYXRpb25zIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJhdGNoR2V0UHJvZHVjdHNTYXZlRGF0YShwcm9kdWN0SWRzOiBzdHJpbmdbXSk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBkYXRhPzogU2F2ZURhdGFbXTsgZXJyb3I/OiBzdHJpbmcgfT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ1VzZXIgbm90IGF1dGhlbnRpY2F0ZWQnIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLnJwYygnZ2V0X3Byb2R1Y3RzX3NhdmVfZGF0YScgYXMgYW55LCB7XG4gICAgICAgICAgICAgICAgcHJvZHVjdF91dWlkczogcHJvZHVjdElkcyxcbiAgICAgICAgICAgICAgICB1c2VyX3V1aWQ6IHVzZXIuaWRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzYXZlRGF0YTogU2F2ZURhdGFbXSA9IChkYXRhIGFzIGFueVtdKT8ubWFwKChpdGVtOiBhbnkpID0+ICh7XG4gICAgICAgICAgICBwcm9kdWN0SWQ6IGl0ZW0ucHJvZHVjdF9pZCxcbiAgICAgICAgICAgIGlzU2F2ZWQ6IGl0ZW0uaXNfc2F2ZWQsXG4gICAgICAgICAgICBzYXZlQ291bnQ6IGl0ZW0uc2F2ZV9jb3VudFxuICAgICAgICB9KSkgfHwgW107XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogc2F2ZURhdGEgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGJhdGNoIHNhdmUgZGF0YTonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnRmFpbGVkIHRvIGdldCBiYXRjaCBzYXZlIGRhdGEnXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYmF0Y2hUb2dnbGVTYXZlcyhcbiAgICBwcm9kdWN0SWRzOiBzdHJpbmdbXSxcbiAgICBhY3Rpb246ICdzYXZlJyB8ICd1bnNhdmUnXG4pOiBQcm9taXNlPEJhdGNoU2F2ZVJlc3VsdD4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ1VzZXIgbm90IGF1dGhlbnRpY2F0ZWQnIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLnJwYygnYmF0Y2hfdG9nZ2xlX3NhdmVzJyBhcyBhbnksIHtcbiAgICAgICAgICAgICAgICBwcm9kdWN0X3V1aWRzOiBwcm9kdWN0SWRzLFxuICAgICAgICAgICAgICAgIHVzZXJfdXVpZDogdXNlci5pZCxcbiAgICAgICAgICAgICAgICBhY3Rpb246IGFjdGlvblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSAoZGF0YSBhcyBhbnlbXSk/Lm1hcCgoaXRlbTogYW55KSA9PiAoe1xuICAgICAgICAgICAgcHJvZHVjdElkOiBpdGVtLnByb2R1Y3RfaWQsXG4gICAgICAgICAgICBpc1NhdmVkOiBhY3Rpb24gPT09ICdzYXZlJyxcbiAgICAgICAgICAgIHNhdmVDb3VudDogaXRlbS5uZXdfc2F2ZV9jb3VudFxuICAgICAgICB9KSkgfHwgW107XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgcmVzdWx0cyB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGJhdGNoIHRvZ2dsaW5nIHNhdmVzOicsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdGYWlsZWQgdG8gYmF0Y2ggdG9nZ2xlIHNhdmVzJ1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gTkVXOiBHZXQgc2F2ZWQgcHJvZHVjdHMgd2l0aCBtZXRhZGF0YSBmb3IgYSBkZWRpY2F0ZWQgc2F2ZWQgcGFnZVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJTYXZlZFByb2R1Y3RzV2l0aE1ldGFkYXRhKCk6IFByb21pc2U8e1xuICAgIHN1Y2Nlc3M6IGJvb2xlYW47XG4gICAgcHJvZHVjdHM/OiBBcnJheTx7XG4gICAgICAgIHByb2R1Y3RJZDogc3RyaW5nO1xuICAgICAgICBzYXZlZEF0OiBzdHJpbmc7XG4gICAgICAgIHByb2R1Y3RUaXRsZTogc3RyaW5nO1xuICAgICAgICBwcm9kdWN0UHJpY2VQZW5jZTogbnVtYmVyO1xuICAgICAgICBwcm9kdWN0SW1hZ2VzOiBzdHJpbmdbXTtcbiAgICB9PjtcbiAgICBlcnJvcj86IHN0cmluZ1xufT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0gfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcigpO1xuICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ1VzZXIgbm90IGF1dGhlbnRpY2F0ZWQnIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLnJwYygnZ2V0X3VzZXJfc2F2ZWRfcHJvZHVjdHNfd2l0aF9tZXRhZGF0YScgYXMgYW55LCB7XG4gICAgICAgICAgICAgICAgdXNlcl91dWlkOiB1c2VyLmlkXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJvZHVjdHMgPSAoZGF0YSBhcyBhbnlbXSk/Lm1hcCgoaXRlbTogYW55KSA9PiAoe1xuICAgICAgICAgICAgcHJvZHVjdElkOiBpdGVtLnByb2R1Y3RfaWQsXG4gICAgICAgICAgICBzYXZlZEF0OiBpdGVtLnNhdmVkX2F0LFxuICAgICAgICAgICAgcHJvZHVjdFRpdGxlOiBpdGVtLnByb2R1Y3RfdGl0bGUsXG4gICAgICAgICAgICBwcm9kdWN0UHJpY2VQZW5jZTogaXRlbS5wcm9kdWN0X3ByaWNlX3BlbmNlLFxuICAgICAgICAgICAgcHJvZHVjdEltYWdlczogaXRlbS5wcm9kdWN0X2ltYWdlcyB8fCBbXVxuICAgICAgICB9KSkgfHwgW107XG5cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgcHJvZHVjdHMgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHNhdmVkIHByb2R1Y3RzIHdpdGggbWV0YWRhdGE6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byBnZXQgc2F2ZWQgcHJvZHVjdHMgd2l0aCBtZXRhZGF0YSdcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbiJdLCJuYW1lcyI6WyJzdXBhYmFzZSIsInJlcXVlc3RDYWNoZSIsIk1hcCIsInBlbmRpbmdSZXF1ZXN0cyIsIlJFUVVFU1RfQ0FDSEVfRFVSQVRJT04iLCJSRVFVRVNUX1RIUk9UVExFX0RFTEFZIiwidGhyb3R0bGVkUmVxdWVzdCIsImtleSIsInJlcXVlc3RGbiIsInVzZUNhY2hlIiwibWF4UmV0cmllcyIsImNhY2hlZCIsImdldCIsIkRhdGUiLCJub3ciLCJ0aW1lc3RhbXAiLCJkYXRhIiwiaGFzIiwicmVxdWVzdFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImF0dGVtcHRzIiwiYXR0ZW1wdFJlcXVlc3QiLCJyZXN1bHQiLCJzZXQiLCJlcnJvciIsInNob3VsZFJldHJ5IiwiZGVsYXkiLCJNYXRoIiwicG93Iiwic2V0VGltZW91dCIsImRlbGV0ZSIsIm1lc3NhZ2UiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwiaW52YWxpZGF0ZUNhY2hlIiwicGF0dGVybiIsImtleXNUb0RlbGV0ZSIsImZvckVhY2giLCJfIiwicHVzaCIsImNsZWFyU2F2ZUNhY2hlIiwiY2xlYXIiLCJzYXZlUHJvZHVjdCIsInByb2R1Y3RJZCIsInVzZXIiLCJhdXRoIiwiZ2V0VXNlciIsInN1Y2Nlc3MiLCJmcm9tIiwiaW5zZXJ0IiwidXNlcl9pZCIsImlkIiwicHJvZHVjdF9pZCIsImNvZGUiLCJzYXZlQ291bnQiLCJjb3VudERhdGEiLCJjb3VudEVycm9yIiwicnBjIiwicHJvZHVjdF91dWlkIiwiY29uc29sZSIsInVuc2F2ZVByb2R1Y3QiLCJlcSIsImdldFVzZXJTYXZlZFByb2R1Y3RzIiwic2VsZWN0Iiwib3JkZXIiLCJhc2NlbmRpbmciLCJwcm9kdWN0SWRzIiwibWFwIiwiaXRlbSIsImdldFByb2R1Y3RTYXZlQ291bnQiLCJjYWNoZUtleSIsImNvdW50IiwiaXNQcm9kdWN0U2F2ZWQiLCJ1c2VyX3V1aWQiLCJpc1NhdmVkIiwiYmF0Y2hHZXRQcm9kdWN0c1NhdmVEYXRhIiwicHJvZHVjdF91dWlkcyIsInNhdmVEYXRhIiwiaXNfc2F2ZWQiLCJzYXZlX2NvdW50IiwiYmF0Y2hUb2dnbGVTYXZlcyIsImFjdGlvbiIsInJlc3VsdHMiLCJuZXdfc2F2ZV9jb3VudCIsImdldFVzZXJTYXZlZFByb2R1Y3RzV2l0aE1ldGFkYXRhIiwicHJvZHVjdHMiLCJzYXZlZEF0Iiwic2F2ZWRfYXQiLCJwcm9kdWN0VGl0bGUiLCJwcm9kdWN0X3RpdGxlIiwicHJvZHVjdFByaWNlUGVuY2UiLCJwcm9kdWN0X3ByaWNlX3BlbmNlIiwicHJvZHVjdEltYWdlcyIsInByb2R1Y3RfaW1hZ2VzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/saves.ts\n"));

/***/ })

});