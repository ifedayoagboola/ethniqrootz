"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/search/page",{

/***/ "(app-pages-browser)/./src/hooks/useSaves.ts":
/*!*******************************!*\
  !*** ./src/hooks/useSaves.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSaves: () => (/* binding */ useSaves)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _stores_saveStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/stores/saveStore */ \"(app-pages-browser)/./src/stores/saveStore.ts\");\n/* harmony import */ var _stores_loadingStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/stores/loadingStore */ \"(app-pages-browser)/./src/stores/loadingStore.ts\");\n/* harmony import */ var _lib_saves__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/saves */ \"(app-pages-browser)/./src/lib/saves.ts\");\n\n\n\n\nfunction useSaves() {\n    const { savedProducts, saveCounts, error, setSavedProducts, addSavedProduct, removeSavedProduct, setSaveCount, setError, isProductSaved: isProductSavedInStore, getSaveCount: getSaveCountFromStore, clearError, batchUpdateSaveData } = (0,_stores_saveStore__WEBPACK_IMPORTED_MODULE_1__.useSaveStore)();\n    const { setLoading } = (0,_stores_loadingStore__WEBPACK_IMPORTED_MODULE_2__.useLoadingStore)();\n    // Load user's saved products on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSaves.useEffect\": ()=>{\n            loadUserSavedProducts();\n        }\n    }[\"useSaves.useEffect\"], []);\n    const loadUserSavedProducts = async ()=>{\n        setLoading(true, 'Loading saved products...');\n        setError(null);\n        try {\n            const result = await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.getUserSavedProducts)();\n            if (result.success && result.productIds) {\n                setSavedProducts(result.productIds);\n            } else if (result.error) {\n                setError(result.error);\n            }\n        } catch (error) {\n            setError('Failed to load saved products');\n        } finally{\n            setLoading(false);\n        }\n    };\n    // Batch load save data for multiple products\n    const loadProductsSaveData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSaves.useCallback[loadProductsSaveData]\": async (productIds)=>{\n            try {\n                const result = await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.batchGetProductsSaveData)(productIds);\n                if (result.success && result.data) {\n                    batchUpdateSaveData(result.data);\n                } else if (result.error) {\n                    console.error('Error loading products save data:', result.error);\n                }\n            } catch (error) {\n                console.error('Error loading products save data:', error);\n            }\n        }\n    }[\"useSaves.useCallback[loadProductsSaveData]\"], [\n        batchUpdateSaveData\n    ]);\n    const loadProductSaveCount = async (productId)=>{\n        try {\n            const result = await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.getProductSaveCount)(productId);\n            if (result.success && result.count !== undefined) {\n                setSaveCount(productId, result.count);\n            }\n        } catch (error) {\n            console.error('Error loading save count:', error);\n        }\n    };\n    const toggleSave = async (productId)=>{\n        setLoading(true, 'Saving...');\n        setError(null);\n        try {\n            const isCurrentlySaved = isProductSavedInStore(productId);\n            const result = isCurrentlySaved ? await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.unsaveProduct)(productId) : await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.saveProduct)(productId);\n            if (result.success) {\n                if (isCurrentlySaved) {\n                    removeSavedProduct(productId);\n                } else {\n                    addSavedProduct(productId);\n                }\n                if (result.saveCount !== undefined) {\n                    setSaveCount(productId, result.saveCount);\n                }\n                return {\n                    success: true\n                };\n            } else {\n                setError(result.error || 'Failed to save product');\n                return {\n                    success: false,\n                    error: result.error\n                };\n            }\n        } catch (error) {\n            const errorMessage = 'Failed to save product';\n            setError(errorMessage);\n            return {\n                success: false,\n                error: errorMessage\n            };\n        } finally{\n            setLoading(false);\n        }\n    };\n    // Batch toggle multiple saves\n    const batchToggleSavesAction = async (productIds, action)=>{\n        setLoading(true, \"\".concat(action === 'save' ? 'Saving' : 'Removing', \" products...\"));\n        setError(null);\n        try {\n            const result = await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.batchToggleSaves)(productIds, action);\n            if (result.success && result.results) {\n                // Update store with batch results\n                result.results.forEach((param)=>{\n                    let { productId, isSaved, saveCount } = param;\n                    if (isSaved) {\n                        addSavedProduct(productId);\n                    } else {\n                        removeSavedProduct(productId);\n                    }\n                    setSaveCount(productId, saveCount);\n                });\n                return {\n                    success: true,\n                    results: result.results\n                };\n            } else {\n                setError(result.error || 'Failed to batch toggle saves');\n                return {\n                    success: false,\n                    error: result.error\n                };\n            }\n        } catch (error) {\n            const errorMessage = 'Failed to batch toggle saves';\n            setError(errorMessage);\n            return {\n                success: false,\n                error: errorMessage\n            };\n        } finally{\n            setLoading(false);\n        }\n    };\n    const checkProductSaveStatus = async (productId)=>{\n        try {\n            const result = await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.isProductSaved)(productId);\n            if (result.success && result.isSaved !== undefined) {\n                if (result.isSaved) {\n                    addSavedProduct(productId);\n                } else {\n                    removeSavedProduct(productId);\n                }\n            }\n        } catch (error) {\n            console.error('Error checking save status:', error);\n        }\n    };\n    return {\n        // State\n        savedProducts: Array.from(savedProducts),\n        saveCounts,\n        error,\n        // Actions\n        toggleSave,\n        batchToggleSaves: batchToggleSavesAction,\n        loadProductSaveCount,\n        loadProductsSaveData,\n        checkProductSaveStatus,\n        loadUserSavedProducts,\n        clearError,\n        // Helpers\n        isProductSaved: isProductSavedInStore,\n        getSaveCount: getSaveCountFromStore\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VTYXZlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0M7QUFDRztBQUNNO0FBU25DO0FBRWQsU0FBU1c7SUFDWixNQUFNLEVBQ0ZDLGFBQWEsRUFDYkMsVUFBVSxFQUNWQyxLQUFLLEVBQ0xDLGdCQUFnQixFQUNoQkMsZUFBZSxFQUNmQyxrQkFBa0IsRUFDbEJDLFlBQVksRUFDWkMsUUFBUSxFQUNSWCxnQkFBZ0JZLHFCQUFxQixFQUNyQ0MsY0FBY0MscUJBQXFCLEVBQ25DQyxVQUFVLEVBQ1ZDLG1CQUFtQixFQUN0QixHQUFHdEIsK0RBQVlBO0lBRWhCLE1BQU0sRUFBRXVCLFVBQVUsRUFBRSxHQUFHdEIscUVBQWVBO0lBRXRDLHNDQUFzQztJQUN0Q0gsZ0RBQVNBOzhCQUFDO1lBQ04wQjtRQUNKOzZCQUFHLEVBQUU7SUFFTCxNQUFNQSx3QkFBd0I7UUFDMUJELFdBQVcsTUFBTTtRQUNqQk4sU0FBUztRQUVULElBQUk7WUFDQSxNQUFNUSxTQUFTLE1BQU1yQixnRUFBb0JBO1lBQ3pDLElBQUlxQixPQUFPQyxPQUFPLElBQUlELE9BQU9FLFVBQVUsRUFBRTtnQkFDckNkLGlCQUFpQlksT0FBT0UsVUFBVTtZQUN0QyxPQUFPLElBQUlGLE9BQU9iLEtBQUssRUFBRTtnQkFDckJLLFNBQVNRLE9BQU9iLEtBQUs7WUFDekI7UUFDSixFQUFFLE9BQU9BLE9BQU87WUFDWkssU0FBUztRQUNiLFNBQVU7WUFDTk0sV0FBVztRQUNmO0lBQ0o7SUFFQSw2Q0FBNkM7SUFDN0MsTUFBTUssdUJBQXVCN0Isa0RBQVdBO3NEQUFDLE9BQU80QjtZQUM1QyxJQUFJO2dCQUNBLE1BQU1GLFNBQVMsTUFBTWxCLG9FQUF3QkEsQ0FBQ29CO2dCQUM5QyxJQUFJRixPQUFPQyxPQUFPLElBQUlELE9BQU9JLElBQUksRUFBRTtvQkFDL0JQLG9CQUFvQkcsT0FBT0ksSUFBSTtnQkFDbkMsT0FBTyxJQUFJSixPQUFPYixLQUFL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QUFFO29CQUNoQjdCLGdCQUFnQmtCO2dCQUNwQixPQUFPO29CQUNIakIsbUJBQW1CaUI7Z0JBQ3ZCO1lBQ0o7UUFDSixFQUFFLE9BQU9wQixPQUFPO1lBQ1prQixRQUFRbEIsS0FBSyxDQUFDLCtCQUErQkE7UUFDakQ7SUFDSjtJQUVBLE9BQU87UUFDSCxRQUFRO1FBQ1JGLGVBQWVtQyxNQUFNQyxJQUFJLENBQUNwQztRQUMxQkM7UUFDQUM7UUFFQSxVQUFVO1FBQ1Z1QjtRQUNBM0Isa0JBQWtCK0I7UUFDbEJSO1FBQ0FIO1FBQ0FnQjtRQUNBcEI7UUFDQUg7UUFFQSxVQUFVO1FBQ1ZmLGdCQUFnQlk7UUFDaEJDLGNBQWNDO0lBQ2xCO0FBQ0oiLCJzb3VyY2VzIjpbIi9Vc2Vycy9pZmVkYXlvYWdib29sYS9EZXNrdG9wL215UHJvamVjdHMvZXRobmlxcm9vdHotbmV4dGpzL3NyYy9ob29rcy91c2VTYXZlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlU2F2ZVN0b3JlIH0gZnJvbSAnQC9zdG9yZXMvc2F2ZVN0b3JlJztcbmltcG9ydCB7IHVzZUxvYWRpbmdTdG9yZSB9IGZyb20gJ0Avc3RvcmVzL2xvYWRpbmdTdG9yZSc7XG5pbXBvcnQge1xuICAgIHNhdmVQcm9kdWN0LFxuICAgIHVuc2F2ZVByb2R1Y3QsXG4gICAgZ2V0VXNlclNhdmVkUHJvZHVjdHMsXG4gICAgZ2V0UHJvZHVjdFNhdmVDb3VudCxcbiAgICBpc1Byb2R1Y3RTYXZlZCxcbiAgICBiYXRjaEdldFByb2R1Y3RzU2F2ZURhdGEsXG4gICAgYmF0Y2hUb2dnbGVTYXZlc1xufSBmcm9tICdAL2xpYi9zYXZlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTYXZlcygpIHtcbiAgICBjb25zdCB7XG4gICAgICAgIHNhdmVkUHJvZHVjdHMsXG4gICAgICAgIHNhdmVDb3VudHMsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBzZXRTYXZlZFByb2R1Y3RzLFxuICAgICAgICBhZGRTYXZlZFByb2R1Y3QsXG4gICAgICAgIHJlbW92ZVNhdmVkUHJvZHVjdCxcbiAgICAgICAgc2V0U2F2ZUNvdW50LFxuICAgICAgICBzZXRFcnJvcixcbiAgICAgICAgaXNQcm9kdWN0U2F2ZWQ6IGlzUHJvZHVjdFNhdmVkSW5TdG9yZSxcbiAgICAgICAgZ2V0U2F2ZUNvdW50OiBnZXRTYXZlQ291bnRGcm9tU3RvcmUsXG4gICAgICAgIGNsZWFyRXJyb3IsXG4gICAgICAgIGJhdGNoVXBkYXRlU2F2ZURhdGEsXG4gICAgfSA9IHVzZVNhdmVTdG9yZSgpO1xuXG4gICAgY29uc3QgeyBzZXRMb2FkaW5nIH0gPSB1c2VMb2FkaW5nU3RvcmUoKTtcblxuICAgIC8vIExvYWQgdXNlcidzIHNhdmVkIHByb2R1Y3RzIG9uIG1vdW50XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbG9hZFVzZXJTYXZlZFByb2R1Y3RzKCk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgbG9hZFVzZXJTYXZlZFByb2R1Y3RzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBzZXRMb2FkaW5nKHRydWUsICdMb2FkaW5nIHNhdmVkIHByb2R1Y3RzLi4uJyk7XG4gICAgICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRVc2VyU2F2ZWRQcm9kdWN0cygpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5wcm9kdWN0SWRzKSB7XG4gICAgICAgICAgICAgICAgc2V0U2F2ZWRQcm9kdWN0cyhyZXN1bHQucHJvZHVjdElkcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKHJlc3VsdC5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBzZXRFcnJvcignRmFpbGVkIHRvIGxvYWQgc2F2ZWQgcHJvZHVjdHMnKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEJhdGNoIGxvYWQgc2F2ZSBkYXRhIGZvciBtdWx0aXBsZSBwcm9kdWN0c1xuICAgIGNvbnN0IGxvYWRQcm9kdWN0c1NhdmVEYXRhID0gdXNlQ2FsbGJhY2soYXN5bmMgKHByb2R1Y3RJZHM6IHN0cmluZ1tdKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBiYXRjaEdldFByb2R1Y3RzU2F2ZURhdGEocHJvZHVjdElkcyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICBiYXRjaFVwZGF0ZVNhdmVEYXRhKHJlc3VsdC5kYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBwcm9kdWN0cyBzYXZlIGRhdGE6JywgcmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgcHJvZHVjdHMgc2F2ZSBkYXRhOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0sIFtiYXRjaFVwZGF0ZVNhdmVEYXRhXSk7XG5cbiAgICBjb25zdCBsb2FkUHJvZHVjdFNhdmVDb3VudCA9IGFzeW5jIChwcm9kdWN0SWQ6IHN0cmluZykgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0UHJvZHVjdFNhdmVDb3VudChwcm9kdWN0SWQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5jb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2V0U2F2ZUNvdW50KHByb2R1Y3RJZCwgcmVzdWx0LmNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgc2F2ZSBjb3VudDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgdG9nZ2xlU2F2ZSA9IGFzeW5jIChwcm9kdWN0SWQ6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiA9PiB7XG4gICAgICAgIHNldExvYWRpbmcodHJ1ZSwgJ1NhdmluZy4uLicpO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50bHlTYXZlZCA9IGlzUHJvZHVjdFNhdmVkSW5TdG9yZShwcm9kdWN0SWQpO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpc0N1cnJlbnRseVNhdmVkXG4gICAgICAgICAgICAgICAgPyBhd2FpdCB1bnNhdmVQcm9kdWN0KHByb2R1Y3RJZClcbiAgICAgICAgICAgICAgICA6IGF3YWl0IHNhdmVQcm9kdWN0KHByb2R1Y3RJZCk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRseVNhdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVNhdmVkUHJvZHVjdChwcm9kdWN0SWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFNhdmVkUHJvZHVjdChwcm9kdWN0SWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc2F2ZUNvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2F2ZUNvdW50KHByb2R1Y3RJZCwgcmVzdWx0LnNhdmVDb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcihyZXN1bHQuZXJyb3IgfHwgJ0ZhaWxlZCB0byBzYXZlIHByb2R1Y3QnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHJlc3VsdC5lcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ0ZhaWxlZCB0byBzYXZlIHByb2R1Y3QnO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3JNZXNzYWdlIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBCYXRjaCB0b2dnbGUgbXVsdGlwbGUgc2F2ZXNcbiAgICBjb25zdCBiYXRjaFRvZ2dsZVNhdmVzQWN0aW9uID0gYXN5bmMgKFxuICAgICAgICBwcm9kdWN0SWRzOiBzdHJpbmdbXSxcbiAgICAgICAgYWN0aW9uOiAnc2F2ZScgfCAndW5zYXZlJ1xuICAgICk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZzsgcmVzdWx0cz86IGFueVtdIH0+ID0+IHtcbiAgICAgICAgc2V0TG9hZGluZyh0cnVlLCBgJHthY3Rpb24gPT09ICdzYXZlJyA/ICdTYXZpbmcnIDogJ1JlbW92aW5nJ30gcHJvZHVjdHMuLi5gKTtcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJhdGNoVG9nZ2xlU2F2ZXMocHJvZHVjdElkcywgYWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcyAmJiByZXN1bHQucmVzdWx0cykge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzdG9yZSB3aXRoIGJhdGNoIHJlc3VsdHNcbiAgICAgICAgICAgICAgICByZXN1bHQucmVzdWx0cy5mb3JFYWNoKCh7IHByb2R1Y3RJZCwgaXNTYXZlZCwgc2F2ZUNvdW50IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2F2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFNhdmVkUHJvZHVjdChwcm9kdWN0SWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlU2F2ZWRQcm9kdWN0KHByb2R1Y3RJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0U2F2ZUNvdW50KHByb2R1Y3RJZCwgc2F2ZUNvdW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCByZXN1bHRzOiByZXN1bHQucmVzdWx0cyB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcihyZXN1bHQuZXJyb3IgfHwgJ0ZhaWxlZCB0byBiYXRjaCB0b2dnbGUgc2F2ZXMnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHJlc3VsdC5lcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ0ZhaWxlZCB0byBiYXRjaCB0b2dnbGUgc2F2ZXMnO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3JNZXNzYWdlIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBjaGVja1Byb2R1Y3RTYXZlU3RhdHVzID0gYXN5bmMgKHByb2R1Y3RJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpc1Byb2R1Y3RTYXZlZChwcm9kdWN0SWQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5pc1NhdmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmlzU2F2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU2F2ZWRQcm9kdWN0KHByb2R1Y3RJZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlU2F2ZWRQcm9kdWN0KHByb2R1Y3RJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgc2F2ZSBzdGF0dXM6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8vIFN0YXRlXG4gICAgICAgIHNhdmVkUHJvZHVjdHM6IEFycmF5LmZyb20oc2F2ZWRQcm9kdWN0cyksXG4gICAgICAgIHNhdmVDb3VudHMsXG4gICAgICAgIGVycm9yLFxuXG4gICAgICAgIC8vIEFjdGlvbnNcbiAgICAgICAgdG9nZ2xlU2F2ZSxcbiAgICAgICAgYmF0Y2hUb2dnbGVTYXZlczogYmF0Y2hUb2dnbGVTYXZlc0FjdGlvbixcbiAgICAgICAgbG9hZFByb2R1Y3RTYXZlQ291bnQsXG4gICAgICAgIGxvYWRQcm9kdWN0c1NhdmVEYXRhLFxuICAgICAgICBjaGVja1Byb2R1Y3RTYXZlU3RhdHVzLFxuICAgICAgICBsb2FkVXNlclNhdmVkUHJvZHVjdHMsXG4gICAgICAgIGNsZWFyRXJyb3IsXG5cbiAgICAgICAgLy8gSGVscGVyc1xuICAgICAgICBpc1Byb2R1Y3RTYXZlZDogaXNQcm9kdWN0U2F2ZWRJblN0b3JlLFxuICAgICAgICBnZXRTYXZlQ291bnQ6IGdldFNhdmVDb3VudEZyb21TdG9yZSxcbiAgICB9O1xufVxuXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VTYXZlU3RvcmUiLCJ1c2VMb2FkaW5nU3RvcmUiLCJzYXZlUHJvZHVjdCIsInVuc2F2ZVByb2R1Y3QiLCJnZXRVc2VyU2F2ZWRQcm9kdWN0cyIsImdldFByb2R1Y3RTYXZlQ291bnQiLCJpc1Byb2R1Y3RTYXZlZCIsImJhdGNoR2V0UHJvZHVjdHNTYXZlRGF0YSIsImJhdGNoVG9nZ2xlU2F2ZXMiLCJ1c2VTYXZlcyIsInNhdmVkUHJvZHVjdHMiLCJzYXZlQ291bnRzIiwiZXJyb3IiLCJzZXRTYXZlZFByb2R1Y3RzIiwiYWRkU2F2ZWRQcm9kdWN0IiwicmVtb3ZlU2F2ZWRQcm9kdWN0Iiwic2V0U2F2ZUNvdW50Iiwic2V0RXJyb3IiLCJpc1Byb2R1Y3RTYXZlZEluU3RvcmUiLCJnZXRTYXZlQ291bnQiLCJnZXRTYXZlQ291bnRGcm9tU3RvcmUiLCJjbGVhckVycm9yIiwiYmF0Y2hVcGRhdGVTYXZlRGF0YSIsInNldExvYWRpbmciLCJsb2FkVXNlclNhdmVkUHJvZHVjdHMiLCJyZXN1bHQiLCJzdWNjZXNzIiwicHJvZHVjdElkcyIsImxvYWRQcm9kdWN0c1NhdmVEYXRhIiwiZGF0YSIsImNvbnNvbGUiLCJsb2FkUHJvZHVjdFNhdmVDb3VudCIsInByb2R1Y3RJZCIsImNvdW50IiwidW5kZWZpbmVkIiwidG9nZ2xlU2F2ZSIsImlzQ3VycmVudGx5U2F2ZWQiLCJzYXZlQ291bnQiLCJlcnJvck1lc3NhZ2UiLCJiYXRjaFRvZ2dsZVNhdmVzQWN0aW9uIiwiYWN0aW9uIiwicmVzdWx0cyIsImZvckVhY2giLCJpc1NhdmVkIiwiY2hlY2tQcm9kdWN0U2F2ZVN0YXR1cyIsIkFycmF5IiwiZnJvbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useSaves.ts\n"));

/***/ })

});