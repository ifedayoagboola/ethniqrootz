"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/product/[id]/page",{

/***/ "(app-pages-browser)/./src/hooks/useSaves.ts":
/*!*******************************!*\
  !*** ./src/hooks/useSaves.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSaves: () => (/* binding */ useSaves)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _stores_saveStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/stores/saveStore */ \"(app-pages-browser)/./src/stores/saveStore.ts\");\n/* harmony import */ var _stores_loadingStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/stores/loadingStore */ \"(app-pages-browser)/./src/stores/loadingStore.ts\");\n/* harmony import */ var _lib_saves__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/saves */ \"(app-pages-browser)/./src/lib/saves.ts\");\n\n\n\n\nfunction useSaves() {\n    const { savedProducts, saveCounts, error, setSavedProducts, addSavedProduct, removeSavedProduct, setSaveCount, setError, isProductSaved: isProductSavedInStore, getSaveCount: getSaveCountFromStore, clearError, batchUpdateSaveData } = (0,_stores_saveStore__WEBPACK_IMPORTED_MODULE_1__.useSaveStore)();\n    const { setLoading } = (0,_stores_loadingStore__WEBPACK_IMPORTED_MODULE_2__.useLoadingStore)();\n    // Load user's saved products on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useSaves.useEffect\": ()=>{\n            loadUserSavedProducts();\n        }\n    }[\"useSaves.useEffect\"], []);\n    const loadUserSavedProducts = async ()=>{\n        setLoading(true);\n        setError(null);\n        try {\n            const result = await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.getUserSavedProducts)();\n            if (result.success && result.productIds) {\n                setSavedProducts(result.productIds);\n            } else if (result.error) {\n                setError(result.error);\n            }\n        } catch (error) {\n            setError('Failed to load saved products');\n        } finally{\n            setLoading(false);\n        }\n    };\n    // Batch load save data for multiple products\n    const loadProductsSaveData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSaves.useCallback[loadProductsSaveData]\": async (productIds)=>{\n            try {\n                const result = await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.batchGetProductsSaveData)(productIds);\n                if (result.success && result.data) {\n                    batchUpdateSaveData(result.data);\n                } else if (result.error) {\n                    console.error('Error loading products save data:', result.error);\n                }\n            } catch (error) {\n                console.error('Error loading products save data:', error);\n            }\n        }\n    }[\"useSaves.useCallback[loadProductsSaveData]\"], [\n        batchUpdateSaveData\n    ]);\n    const loadProductSaveCount = async (productId)=>{\n        try {\n            const result = await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.getProductSaveCount)(productId);\n            if (result.success && result.count !== undefined) {\n                setSaveCount(productId, result.count);\n            } else if (result.error) {\n                console.error('Error loading save count:', result.error);\n            }\n        } catch (error) {\n            console.error('Error loading save count:', error);\n        }\n    };\n    const toggleSave = async (productId)=>{\n        setLoading(true, 'Saving...');\n        setError(null);\n        try {\n            const isCurrentlySaved = isProductSavedInStore(productId);\n            const result = isCurrentlySaved ? await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.unsaveProduct)(productId) : await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.saveProduct)(productId);\n            if (result.success) {\n                if (isCurrentlySaved) {\n                    removeSavedProduct(productId);\n                } else {\n                    addSavedProduct(productId);\n                }\n                if (result.saveCount !== undefined) {\n                    setSaveCount(productId, result.saveCount);\n                }\n                return {\n                    success: true\n                };\n            } else {\n                setError(result.error || 'Failed to save product');\n                return {\n                    success: false,\n                    error: result.error\n                };\n            }\n        } catch (error) {\n            const errorMessage = 'Failed to save product';\n            setError(errorMessage);\n            return {\n                success: false,\n                error: errorMessage\n            };\n        } finally{\n            setLoading(false);\n        }\n    };\n    // Batch toggle multiple saves\n    const batchToggleSavesAction = async (productIds, action)=>{\n        setLoading(true, \"\".concat(action === 'save' ? 'Saving' : 'Removing', \" products...\"));\n        setError(null);\n        try {\n            const result = await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.batchToggleSaves)(productIds, action);\n            if (result.success && result.results) {\n                // Update store with batch results\n                result.results.forEach((param)=>{\n                    let { productId, isSaved, saveCount } = param;\n                    if (isSaved) {\n                        addSavedProduct(productId);\n                    } else {\n                        removeSavedProduct(productId);\n                    }\n                    setSaveCount(productId, saveCount);\n                });\n                return {\n                    success: true,\n                    results: result.results\n                };\n            } else {\n                setError(result.error || 'Failed to batch toggle saves');\n                return {\n                    success: false,\n                    error: result.error\n                };\n            }\n        } catch (error) {\n            const errorMessage = 'Failed to batch toggle saves';\n            setError(errorMessage);\n            return {\n                success: false,\n                error: errorMessage\n            };\n        } finally{\n            setLoading(false);\n        }\n    };\n    const checkProductSaveStatus = async (productId)=>{\n        try {\n            const result = await (0,_lib_saves__WEBPACK_IMPORTED_MODULE_3__.isProductSaved)(productId);\n            if (result.success && result.isSaved !== undefined) {\n                if (result.isSaved) {\n                    addSavedProduct(productId);\n                } else {\n                    removeSavedProduct(productId);\n                }\n            } else if (result.error) {\n                console.error('Error checking save status:', result.error);\n            }\n        } catch (error) {\n            console.error('Error checking save status:', error);\n        }\n    };\n    return {\n        // State\n        savedProducts: Array.from(savedProducts),\n        saveCounts,\n        error,\n        // Actions\n        toggleSave,\n        batchToggleSaves: batchToggleSavesAction,\n        loadProductSaveCount,\n        loadProductsSaveData,\n        checkProductSaveStatus,\n        loadUserSavedProducts,\n        clearError,\n        // Helpers\n        isProductSaved: isProductSavedInStore,\n        getSaveCount: getSaveCountFromStore\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VTYXZlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0M7QUFDRztBQUNNO0FBU25DO0FBRWQsU0FBU1c7SUFDWixNQUFNLEVBQ0ZDLGFBQWEsRUFDYkMsVUFBVSxFQUNWQyxLQUFLLEVBQ0xDLGdCQUFnQixFQUNoQkMsZUFBZSxFQUNmQyxrQkFBa0IsRUFDbEJDLFlBQVksRUFDWkMsUUFBUSxFQUNSWCxnQkFBZ0JZLHFCQUFxQixFQUNyQ0MsY0FBY0MscUJBQXFCLEVBQ25DQyxVQUFVLEVBQ1ZDLG1CQUFtQixFQUN0QixHQUFHdEIsK0RBQVlBO0lBRWhCLE1BQU0sRUFBRXVCLFVBQVUsRUFBRSxHQUFHdEIscUVBQWVBO0lBRXRDLHNDQUFzQztJQUN0Q0gsZ0RBQVNBOzhCQUFDO1lBQ04wQjtRQUNKOzZCQUFHLEVBQUU7SUFFTCxNQUFNQSx3QkFBd0I7UUFDMUJELFdBQVc7UUFDWE4sU0FBUztRQUVULElBQUk7WUFDQSxNQUFNUSxTQUFTLE1BQU1yQixnRUFBb0JBO1lBQ3pDLElBQUlxQixPQUFPQyxPQUFPLElBQUlELE9BQU9FLFVBQVUsRUFBRTtnQkFDckNkLGlCQUFpQlksT0FBT0UsVUFBVTtZQUN0QyxPQUFPLElBQUlGLE9BQU9iLEtBQUssRUFBRTtnQkFDckJLLFNBQVNRLE9BQU9iLEtBQUs7WUFDekI7UUFDSixFQUFFLE9BQU9BLE9BQU87WUFDWkssU0FBUztRQUNiLFNBQVU7WUFDTk0sV0FBVztRQUNmO0lBQ0o7SUFFQSw2Q0FBNkM7SUFDN0MsTUFBTUssdUJBQXVCN0Isa0RBQVdBO3NEQUFDLE9BQU80QjtZQUM1QyxJQUFJO2dCQUNBLE1BQU1GLFNBQVMsTUFBTWxCLG9FQUF3QkEsQ0FBQ29CO2dCQUM5QyxJQUFJRixPQUFPQyxPQUFPLElBQUlELE9BQU9JLElBQUksRUFBRTtvQkFDL0JQLG9CQUFvQkcsT0FBT0ksSUFBSTtnQkFDbkMsT0FBTyxJQUFJSixPQUFPYixLQUFLLEVBQUU7b0JBQ3JCa0IsUUFBUWxCLEtBQUssQ0FBQyxxQ0FBcUNhLE9BQU9iLEtBQUs7Z0JBQ25FO1lBQ0osRUFBRSxPQUFPQSxPQUFPO2dCQUNaa0IsUUFBUWxCLEtBQUssQ0FBQyxxQ0FBcUNBO1lBQ3ZEO1FBQ0o7cURBQUc7UUFBQ1U7S0FBb0I7SUFFeEIsTUFBTVMsdUJBQXVCLE9BQU9DO1FBQ2hDLElBQUk7WUFDQSxNQUFNUCxTQUFTLE1BQU1wQiwrREFBbUJBLENBQUMyQjtZQUN6QyxJQUFJUCxPQUFPQyxPQUFPLElBQUlELE9BQU9RLEtBQUssS0FBS0MsV0FBVztnQkFDOUNsQixhQUFhZ0IsV0FBV1AsT0FBT1EsS0FBSztZQUN4QyxPQUFPLElBQUlSLE9BQU9iLEtBQUssRUFBRTtnQkFDckJrQixRQUFRbEIsS0FBSyxDQUFDLDZCQUE2QmEsT0FBT2IsS0FBSztZQUMzRDtRQUNKLEVBQUUsT0FBT0EsT0FBTztZQUNaa0IsUUFBUWxCLEtBQUssQ0FBQyw2QkFBNkJBO1FBQy9DO0lBQ0o7SUFFQSxNQUFNdUIsYUFBYSxPQUFPSDtRQUN0QlQsV0FBVyxNQUFNO1FBQ2pCTixTQUFTO1FBRVQsSUFBSTtZQUNBLE1BQU1tQixtQkFBbUJsQixzQkFBc0JjO1lBRS9DLE1BQU1QLFNBQVNXLG1CQUNULE1BQU1qQyx5REFBYUEsQ0FBQzZCLGFBQ3BCLE1BQU05Qix1REFBV0EsQ0FBQzhCO1lBRXhCLElBQUlQLE9BQU9DLE9BQU8sRUFBRTtnQkFDaEIsSUFBSVUsa0JBQWtCO29CQUNsQnJCLG1CQUFtQmlCO2dCQUN2QixPQUFPO29CQUNIbEIsZ0JBQWdCa0I7Z0JBQ3BCO2dCQUVBLElBQUlQLE9BQU9ZLFNBQVMsS0FBS0gsV0FBVztvQkFDaENsQixhQUFhZ0IsV0FBV1AsT0FBT1ksU0FBUztnQkFDNUM7Z0JBRUEsT0FBTztvQkFBRVgsU0FBUztnQkFBSztZQUMzQixPQUFPO2dCQUNIVCxTQUFTUSxPQUFPYixLQUFLLElBQUk7Z0JBQ3pCLE9BQU87b0JBQUVjLFNBQVM7b0JBQU9kLE9BQU9hLE9BQU9iLEtBQUs7Z0JBQUM7WUFDakQ7UUFDSixFQUFFLE9BQU9BLE9BQU87WUFDWixNQUFNMEIsZUFBZTtZQUNyQnJCLFNBQVNxQjtZQUNULE9BQU87Z0JBQUVaLFNBQVM7Z0JBQU9kLE9BQU8wQjtZQUFhO1FBQ2pELFNBQVU7WUFDTmYsV0FBVztRQUNmO0lBQ0o7SUFFQSw4QkFBOEI7SUFDOUIsTUFBTWdCLHlCQUF5QixPQUMzQlosWUFDQWE7UUFFQWpCLFdBQVcsTUFBTSxHQUE2QyxPQUExQ2lCLFdBQVcsU0FBUyxXQUFXLFlBQVc7UUFDOUR2QixTQUFTO1FBRVQsSUFBSTtZQUNBLE1BQU1RLFNBQVMsTUFBTWpCLDREQUFnQkEsQ0FBQ21CLFlBQVlhO1lBQ2xELElBQUlmLE9BQU9DLE9BQU8sSUFBSUQsT0FBT2dCLE9BQU8sRUFBRTtnQkFDbEMsa0NBQWtDO2dCQUNsQ2hCLE9BQU9nQixPQUFPLENBQUNDLE9BQU8sQ0FBQzt3QkFBQyxFQUFFVixTQUFTLEVBQUVXLE9BQU8sRUFBRU4sU0FBUyxFQUFFO29CQUNyRCxJQUFJTSxTQUFTO3dCQUNUN0IsZ0JBQWdCa0I7b0JBQ3BCLE9BQU87d0JBQ0hqQixtQkFBbUJpQjtvQkFDdkI7b0JBQ0FoQixhQUFhZ0IsV0FBV0s7Z0JBQzVCO2dCQUNBLE9BQU87b0JBQUVYLFNBQVM7b0JBQU1lLFNBQVNoQixPQUFPZ0IsT0FBTztnQkFBQztZQUNwRCxPQUFPO2dCQUNIeEIsU0FBU1EsT0FBT2IsS0FBSyxJQUFJO2dCQUN6QixPQUFPO29CQUFFYyxTQUFTO29CQUFPZCxPQUFPYSxPQUFPYixLQUFLO2dCQUFDO1lBQ2pEO1FBQ0osRUFBRSxPQUFPQSxPQUFPO1lBQ1osTUFBTTBCLGVBQWU7WUFDckJyQixTQUFTcUI7WUFDVCxPQUFPO2dCQUFFWixTQUFTO2dCQUFPZCxPQUFPMEI7WUFBYTtRQUNqRCxTQUFVO1lBQ05mLFdBQVc7UUFDZjtJQUNKO0lBRUEsTUFBTXFCLHlCQUF5QixPQUFPWjtRQUNsQyxJQUFJO1lBQ0EsTUFBTVAsU0FBUyxNQUFNbkIsMERBQWNBLENBQUMwQjtZQUNwQyxJQUFJUCxPQUFPQyxPQUFPLElBQUlELE9BQU9rQixPQUFPLEtBQUtULFdBQVc7Z0JBQ2hELElBQUlULE9BQU9rQixPQUFPLEVBQUU7b0JBQ2hCN0IsZ0JBQWdCa0I7Z0JBQ3BCLE9BQU87b0JBQ0hqQixtQkFBbUJpQjtnQkFDdkI7WUFDSixPQUFPLElBQUlQLE9BQU9iLEtBQUssRUFBRTtnQkFDckJrQixRQUFRbEIsS0FBSyxDQUFDLCtCQUErQmEsT0FBT2IsS0FBSztZQUM3RDtRQUNKLEVBQUUsT0FBT0EsT0FBTztZQUNaa0IsUUFBUWxCLEtBQUssQ0FBQywrQkFBK0JBO1FBQ2pEO0lBQ0o7SUFFQSxPQUFPO1FBQ0gsUUFBUTtRQUNSRixlQUFlbUMsTUFBTUMsSUFBSSxDQUFDcEM7UUFDMUJDO1FBQ0FDO1FBRUEsVUFBVTtRQUNWdUI7UUFDQTNCLGtCQUFrQitCO1FBQ2xCUjtRQUNBSDtRQUNBZ0I7UUFDQXBCO1FBQ0FIO1FBRUEsVUFBVTtRQUNWZixnQkFBZ0JZO1FBQ2hCQyxjQUFjQztJQUNsQjtBQUNKIiwic291cmNlcyI6WyIvVXNlcnMvaWZlZGF5b2FnYm9vbGEvRGVza3RvcC9teVByb2plY3RzL2V0aG5pcXJvb3R6LW5leHRqcy9zcmMvaG9va3MvdXNlU2F2ZXMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVNhdmVTdG9yZSB9IGZyb20gJ0Avc3RvcmVzL3NhdmVTdG9yZSc7XG5pbXBvcnQgeyB1c2VMb2FkaW5nU3RvcmUgfSBmcm9tICdAL3N0b3Jlcy9sb2FkaW5nU3RvcmUnO1xuaW1wb3J0IHtcbiAgICBzYXZlUHJvZHVjdCxcbiAgICB1bnNhdmVQcm9kdWN0LFxuICAgIGdldFVzZXJTYXZlZFByb2R1Y3RzLFxuICAgIGdldFByb2R1Y3RTYXZlQ291bnQsXG4gICAgaXNQcm9kdWN0U2F2ZWQsXG4gICAgYmF0Y2hHZXRQcm9kdWN0c1NhdmVEYXRhLFxuICAgIGJhdGNoVG9nZ2xlU2F2ZXNcbn0gZnJvbSAnQC9saWIvc2F2ZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU2F2ZXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgICBzYXZlZFByb2R1Y3RzLFxuICAgICAgICBzYXZlQ291bnRzLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgc2V0U2F2ZWRQcm9kdWN0cyxcbiAgICAgICAgYWRkU2F2ZWRQcm9kdWN0LFxuICAgICAgICByZW1vdmVTYXZlZFByb2R1Y3QsXG4gICAgICAgIHNldFNhdmVDb3VudCxcbiAgICAgICAgc2V0RXJyb3IsXG4gICAgICAgIGlzUHJvZHVjdFNhdmVkOiBpc1Byb2R1Y3RTYXZlZEluU3RvcmUsXG4gICAgICAgIGdldFNhdmVDb3VudDogZ2V0U2F2ZUNvdW50RnJvbVN0b3JlLFxuICAgICAgICBjbGVhckVycm9yLFxuICAgICAgICBiYXRjaFVwZGF0ZVNhdmVEYXRhLFxuICAgIH0gPSB1c2VTYXZlU3RvcmUoKTtcblxuICAgIGNvbnN0IHsgc2V0TG9hZGluZyB9ID0gdXNlTG9hZGluZ1N0b3JlKCk7XG5cbiAgICAvLyBMb2FkIHVzZXIncyBzYXZlZCBwcm9kdWN0cyBvbiBtb3VudFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxvYWRVc2VyU2F2ZWRQcm9kdWN0cygpO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGxvYWRVc2VyU2F2ZWRQcm9kdWN0cyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldFVzZXJTYXZlZFByb2R1Y3RzKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LnByb2R1Y3RJZHMpIHtcbiAgICAgICAgICAgICAgICBzZXRTYXZlZFByb2R1Y3RzKHJlc3VsdC5wcm9kdWN0SWRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IocmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gbG9hZCBzYXZlZCBwcm9kdWN0cycpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQmF0Y2ggbG9hZCBzYXZlIGRhdGEgZm9yIG11bHRpcGxlIHByb2R1Y3RzXG4gICAgY29uc3QgbG9hZFByb2R1Y3RzU2F2ZURhdGEgPSB1c2VDYWxsYmFjayhhc3luYyAocHJvZHVjdElkczogc3RyaW5nW10pID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJhdGNoR2V0UHJvZHVjdHNTYXZlRGF0YShwcm9kdWN0SWRzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcyAmJiByZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgICAgIGJhdGNoVXBkYXRlU2F2ZURhdGEocmVzdWx0LmRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHByb2R1Y3RzIHNhdmUgZGF0YTonLCByZXN1bHQuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBwcm9kdWN0cyBzYXZlIGRhdGE6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSwgW2JhdGNoVXBkYXRlU2F2ZURhdGFdKTtcblxuICAgIGNvbnN0IGxvYWRQcm9kdWN0U2F2ZUNvdW50ID0gYXN5bmMgKHByb2R1Y3RJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRQcm9kdWN0U2F2ZUNvdW50KHByb2R1Y3RJZCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MgJiYgcmVzdWx0LmNvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRTYXZlQ291bnQocHJvZHVjdElkLCByZXN1bHQuY291bnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHNhdmUgY291bnQ6JywgcmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgc2F2ZSBjb3VudDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgdG9nZ2xlU2F2ZSA9IGFzeW5jIChwcm9kdWN0SWQ6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiA9PiB7XG4gICAgICAgIHNldExvYWRpbmcodHJ1ZSwgJ1NhdmluZy4uLicpO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50bHlTYXZlZCA9IGlzUHJvZHVjdFNhdmVkSW5TdG9yZShwcm9kdWN0SWQpO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpc0N1cnJlbnRseVNhdmVkXG4gICAgICAgICAgICAgICAgPyBhd2FpdCB1bnNhdmVQcm9kdWN0KHByb2R1Y3RJZClcbiAgICAgICAgICAgICAgICA6IGF3YWl0IHNhdmVQcm9kdWN0KHByb2R1Y3RJZCk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRseVNhdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVNhdmVkUHJvZHVjdChwcm9kdWN0SWQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFNhdmVkUHJvZHVjdChwcm9kdWN0SWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc2F2ZUNvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2F2ZUNvdW50KHByb2R1Y3RJZCwgcmVzdWx0LnNhdmVDb3VudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcihyZXN1bHQuZXJyb3IgfHwgJ0ZhaWxlZCB0byBzYXZlIHByb2R1Y3QnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHJlc3VsdC5lcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ0ZhaWxlZCB0byBzYXZlIHByb2R1Y3QnO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3JNZXNzYWdlIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBCYXRjaCB0b2dnbGUgbXVsdGlwbGUgc2F2ZXNcbiAgICBjb25zdCBiYXRjaFRvZ2dsZVNhdmVzQWN0aW9uID0gYXN5bmMgKFxuICAgICAgICBwcm9kdWN0SWRzOiBzdHJpbmdbXSxcbiAgICAgICAgYWN0aW9uOiAnc2F2ZScgfCAndW5zYXZlJ1xuICAgICk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZzsgcmVzdWx0cz86IGFueVtdIH0+ID0+IHtcbiAgICAgICAgc2V0TG9hZGluZyh0cnVlLCBgJHthY3Rpb24gPT09ICdzYXZlJyA/ICdTYXZpbmcnIDogJ1JlbW92aW5nJ30gcHJvZHVjdHMuLi5gKTtcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJhdGNoVG9nZ2xlU2F2ZXMocHJvZHVjdElkcywgYWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcyAmJiByZXN1bHQucmVzdWx0cykge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzdG9yZSB3aXRoIGJhdGNoIHJlc3VsdHNcbiAgICAgICAgICAgICAgICByZXN1bHQucmVzdWx0cy5mb3JFYWNoKCh7IHByb2R1Y3RJZCwgaXNTYXZlZCwgc2F2ZUNvdW50IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2F2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFNhdmVkUHJvZHVjdChwcm9kdWN0SWQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlU2F2ZWRQcm9kdWN0KHByb2R1Y3RJZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0U2F2ZUNvdW50KHByb2R1Y3RJZCwgc2F2ZUNvdW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCByZXN1bHRzOiByZXN1bHQucmVzdWx0cyB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcihyZXN1bHQuZXJyb3IgfHwgJ0ZhaWxlZCB0byBiYXRjaCB0b2dnbGUgc2F2ZXMnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHJlc3VsdC5lcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gJ0ZhaWxlZCB0byBiYXRjaCB0b2dnbGUgc2F2ZXMnO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3JNZXNzYWdlIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBjaGVja1Byb2R1Y3RTYXZlU3RhdHVzID0gYXN5bmMgKHByb2R1Y3RJZDogc3RyaW5nKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpc1Byb2R1Y3RTYXZlZChwcm9kdWN0SWQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzICYmIHJlc3VsdC5pc1NhdmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmlzU2F2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU2F2ZWRQcm9kdWN0KHByb2R1Y3RJZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlU2F2ZWRQcm9kdWN0KHByb2R1Y3RJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBzYXZlIHN0YXR1czonLCByZXN1bHQuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgc2F2ZSBzdGF0dXM6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8vIFN0YXRlXG4gICAgICAgIHNhdmVkUHJvZHVjdHM6IEFycmF5LmZyb20oc2F2ZWRQcm9kdWN0cyksXG4gICAgICAgIHNhdmVDb3VudHMsXG4gICAgICAgIGVycm9yLFxuXG4gICAgICAgIC8vIEFjdGlvbnNcbiAgICAgICAgdG9nZ2xlU2F2ZSxcbiAgICAgICAgYmF0Y2hUb2dnbGVTYXZlczogYmF0Y2hUb2dnbGVTYXZlc0FjdGlvbixcbiAgICAgICAgbG9hZFByb2R1Y3RTYXZlQ291bnQsXG4gICAgICAgIGxvYWRQcm9kdWN0c1NhdmVEYXRhLFxuICAgICAgICBjaGVja1Byb2R1Y3RTYXZlU3RhdHVzLFxuICAgICAgICBsb2FkVXNlclNhdmVkUHJvZHVjdHMsXG4gICAgICAgIGNsZWFyRXJyb3IsXG5cbiAgICAgICAgLy8gSGVscGVyc1xuICAgICAgICBpc1Byb2R1Y3RTYXZlZDogaXNQcm9kdWN0U2F2ZWRJblN0b3JlLFxuICAgICAgICBnZXRTYXZlQ291bnQ6IGdldFNhdmVDb3VudEZyb21TdG9yZSxcbiAgICB9O1xufVxuXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VTYXZlU3RvcmUiLCJ1c2VMb2FkaW5nU3RvcmUiLCJzYXZlUHJvZHVjdCIsInVuc2F2ZVByb2R1Y3QiLCJnZXRVc2VyU2F2ZWRQcm9kdWN0cyIsImdldFByb2R1Y3RTYXZlQ291bnQiLCJpc1Byb2R1Y3RTYXZlZCIsImJhdGNoR2V0UHJvZHVjdHNTYXZlRGF0YSIsImJhdGNoVG9nZ2xlU2F2ZXMiLCJ1c2VTYXZlcyIsInNhdmVkUHJvZHVjdHMiLCJzYXZlQ291bnRzIiwiZXJyb3IiLCJzZXRTYXZlZFByb2R1Y3RzIiwiYWRkU2F2ZWRQcm9kdWN0IiwicmVtb3ZlU2F2ZWRQcm9kdWN0Iiwic2V0U2F2ZUNvdW50Iiwic2V0RXJyb3IiLCJpc1Byb2R1Y3RTYXZlZEluU3RvcmUiLCJnZXRTYXZlQ291bnQiLCJnZXRTYXZlQ291bnRGcm9tU3RvcmUiLCJjbGVhckVycm9yIiwiYmF0Y2hVcGRhdGVTYXZlRGF0YSIsInNldExvYWRpbmciLCJsb2FkVXNlclNhdmVkUHJvZHVjdHMiLCJyZXN1bHQiLCJzdWNjZXNzIiwicHJvZHVjdElkcyIsImxvYWRQcm9kdWN0c1NhdmVEYXRhIiwiZGF0YSIsImNvbnNvbGUiLCJsb2FkUHJvZHVjdFNhdmVDb3VudCIsInByb2R1Y3RJZCIsImNvdW50IiwidW5kZWZpbmVkIiwidG9nZ2xlU2F2ZSIsImlzQ3VycmVudGx5U2F2ZWQiLCJzYXZlQ291bnQiLCJlcnJvck1lc3NhZ2UiLCJiYXRjaFRvZ2dsZVNhdmVzQWN0aW9uIiwiYWN0aW9uIiwicmVzdWx0cyIsImZvckVhY2giLCJpc1NhdmVkIiwiY2hlY2tQcm9kdWN0U2F2ZVN0YXR1cyIsIkFycmF5IiwiZnJvbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useSaves.ts\n"));

/***/ })

});